/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
/*                                                                          */
/*                         PI_MD:                                           */
/*             The future of simulation technology                          */
/*             ------------------------------------                         */
/*                  Module: test_energy_pimd.c                              */
/*                                                                          */
/* This routine numerically checks forces and pressure tensors              */
/* generated by the energy routine                                          */
/*                                                                          */
/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/


#include "standard_include.h"
#include "../typ_defs/typedefs_gen.h"
#include "../typ_defs/typedefs_class.h"
#include "../typ_defs/typedefs_bnd.h"
#include "../proto_defs/proto_energy_ctrl_entry.h"
#include "../proto_defs/proto_energy_ctrl_local.h"
#include "../proto_defs/proto_intra_entry.h"
#include "../proto_defs/proto_surf_entry.h"
#include "../proto_defs/proto_intra_con_entry.h"
#include "../proto_defs/proto_real_space_entry.h"
#include "../proto_defs/proto_recip3d_entry.h"
#include "../proto_defs/proto_math.h"
#include "../proto_defs/proto_friend_lib_entry.h"
#include "../proto_defs/proto_communicate_wrappers.h"


/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

void test_energy_pimd(CLASS *class, BONDED *bonded, 
                      GENERAL_DATA *general_data)

/*==========================================================================*/
     {/*Begin Routine*/
/*==========================================================================*/
/*         Local Variable declarations                                      */

#include "../typ_defs/typ_mask.h"

  int natm_mall = class->clatoms_info.natm_tot;
  int inter,iii,ioff,ip,iproc;
  int cubic_box_flag;
  double delta;
  int ifp_check,ip_check=1;
  int iperd,ninter;
  int ipart1,ipart2,ipart;
  int j,i,iatm,k,koff,joff;
  int np_beads = class->communicate.np_beads;
  int pi_beads = class->clatoms_info.pi_beads; 
  int pi_beads_proc = class->clatoms_info.pi_beads_proc; 
  double *sx,*sy,*sz;
  double dpi_beads = (double)class->clatoms_info.pi_beads; 
  double vreal,vrecip,vself,vbgr,vlong;
  double vwatts_bond,vwatts_bend,vwatts_tot;
  double vvdw,vcoul,vsurf;
  double vbond,vbend,vbend_bnd,vtors,vonfo,vecor,vonfo_vdw,vonfo_coul;
  double vbend_bnd_bond, vbend_bnd_bend;
  double vbond_free,vbend_free,vtors_free,vbar_free;
  double *fx,*fy,*fz;
  double *fxt,*fyt,*fzt;
  double *xmod,*ymod,*zmod;
  double *xmod_old,*ymod_old,*zmod_old;
  double *pvten,*hmatd;
  double vgen,vgen_p,vgen_m;
  double vgen2,vgen3;
  double fxb,fyb,fzb,pvtenb,cpu2,cpu1,cpu;
  int error_check_on = general_data->error_check_on;
  MPI_Comm comm_beads = class->communicate.comm_beads;
  int rank       = class->communicate.myid;
  double pext = general_data->statepoint.pext;

/*==========================================================================*/
/* I)Initialize */

  /* mal_verify(1); */

  vlong       = 0.0;
  vself       = 0.0;
  vbgr        = 0.0;   
  vecor       = 0.0;
  vrecip      = 0.0;
  vvdw        = 0.0;
  vsurf       = 0.0;
  vcoul       = 0.0;
  vreal       = 0.0;
  vbond       = 0.0;
  vbend       = 0.0;
  vbend_bnd   = 0.0;
  vbend_bnd_bond   = 0.0;
  vbend_bnd_bend   = 0.0;
  vtors       = 0.0;
  vonfo       = 0.0;
  vonfo_vdw   = 0.0;
  vonfo_coul  = 0.0;
  vbond_free  = 0.0;
  vbend_free  = 0.0;
  vtors_free  = 0.0;
  vbar_free   = 0.0;
  vwatts_tot  = 0.0;
  vwatts_bond = 0.0;
  vwatts_bend = 0.0;

  fx    = (double *)cmalloc(class->clatoms_info.natm_tot*sizeof(double))-1;
  fy    = (double *)cmalloc(class->clatoms_info.natm_tot*sizeof(double))-1;
  fz    = (double *)cmalloc(class->clatoms_info.natm_tot*sizeof(double))-1;
  sx   = (double *)cmalloc(natm_mall*sizeof(double))-1;
  sy   = (double *)cmalloc(natm_mall*sizeof(double))-1;
  sz   = (double *)cmalloc(natm_mall*sizeof(double))-1;
  xmod_old  = (double *)cmalloc(natm_mall*sizeof(double))-1;
  ymod_old  = (double *)cmalloc(natm_mall*sizeof(double))-1;
  zmod_old  = (double *)cmalloc(natm_mall*sizeof(double))-1;
  xmod      = class->clatoms_info.xmod;
  ymod      = class->clatoms_info.ymod;
  zmod      = class->clatoms_info.zmod;
  pvten = (double *)cmalloc(9*sizeof(double))-1;
  hmatd = (double *)cmalloc(9*sizeof(double))-1;
  iperd = general_data->cell.iperd;
  gethinv((general_data->cell.hmat),(general_data->cell.hmati),
                                    &(general_data->cell.vol),iperd);
  class->for_scr.wght_ter       = 1.0;
  class->for_scr.wght_ter_res   = 1.0;
  bonded->intra_scr.wght_tra     = 1.0;
  bonded->intra_scr.wght_tra_res = 1.0;
  bonded->intra_scr.wght_ter     = 1.0;
  bonded->intra_scr.wght_ter_res = 1.0;
  for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
    sx[ipart] = xmod[ipart]*general_data->cell.hmati[1]+       
                ymod[ipart]*general_data->cell.hmati[4]+    
                zmod[ipart]*general_data->cell.hmati[7];
    sy[ipart] = xmod[ipart]*general_data->cell.hmati[2]+     
                ymod[ipart]*general_data->cell.hmati[5]+
                zmod[ipart]*general_data->cell.hmati[8];
    sz[ipart] = xmod[ipart]*general_data->cell.hmati[3]+
                ymod[ipart]*general_data->cell.hmati[6]+
                zmod[ipart]*general_data->cell.hmati[9];
  }/*endfor*/

/*==========================================================================*/
/* II) Loop over all the interactions */

if( error_check_on == 1){
 printf("Do you wish to check forces and pressure tensor?(1 or 0)\n");
 scanf("%d",&ifp_check);
}/*endif*/

  if(np_beads>1){
    Barrier(comm_beads);
    Bcast(&ifp_check,1,MPI_INT,0,comm_beads);
    Barrier(comm_beads);
  }


if(ifp_check == 1) {
 if(error_check_on == 1){
  printf("Enter the indices of two atoms whose force you wish checked\n");
  scanf("%d %d",&ipart1,&ipart2);printf("\n");
  printf("Enter the bead to use for this check\n");
  scanf("%d",&ip_check);printf("\n");

   if(ip_check > pi_beads_proc){
       printf("@@@@@@@@@@@@@@@@@@@@_error_@@@@@@@@@@@@@@@@@@@@\n");
       printf(" You have requested a bead which doesn't exist on \n ");
       printf(" any node.  Don't make me hurl!  Pick a\n");
       printf(" number less <= %d, the number of beads \n",pi_beads_proc);
       printf(" per processor. \n");
       printf("@@@@@@@@@@@@@@@@@@@@_error_@@@@@@@@@@@@@@@@@@@@\n");
       fflush(stdout);
       exit(1);
       Finalize();
    }/*endif*/

     if(ipart1 > class->clatoms_info.natm_tot || ipart1 <= 0) {
      printf("The particle number %d you have chosen\n",ipart1);
      printf("is out of range  -- using first particle instead\n");   
      ipart1=1;
     }
     if(ipart2 > class->clatoms_info.natm_tot || ipart2 <= 0) {
      printf("The particle number %d you have chosen\n",ipart2);
      printf("is out of range  -- using last particle instead\n");   
      ipart2=class->clatoms_info.natm_tot;
     }
     if(ip_check > pi_beads || ip_check <= 0) {
      printf("The bead number %d you have chosen\n",ip_check);
      printf("is out of range  -- using first bead instead\n");   
      ip_check=1;
     }
 }/*endif for error check on*/

}/*endif for ifp check*/

       if(np_beads>1){
         Barrier(comm_beads);
         Bcast(&ipart1,1,MPI_INT,0,comm_beads);
       }
       if(np_beads>1){
         Barrier(comm_beads);
         Bcast(&ipart2,1,MPI_INT,0,comm_beads);
       }
       if(np_beads>1){
         Barrier(comm_beads);
         Bcast(&ip_check,1,MPI_INT,0,comm_beads);
         Barrier(comm_beads);
       }

  ninter = 16;
  delta = 1.e-07;
  for(inter=1; inter<=ninter; inter++){

/*---------------------------------------------------------------------------*/
/* A) Get the true force */

 if(error_check_on == 1){
    printf("===============\n");
    if(inter==1) {printf("Checking real_space inter\n");}
    if(inter==2) {printf("Checking long\n");}
    if(inter==3) {printf("Checking ewald: alp = %.10g A^(-1)\n",
                  (general_data->ewald.alp_ewd/BOHR));}
    if(inter==4) {printf("Checking bkgr \n");}
    if(inter==5) {printf("Checking bonds\n");}
    if(inter==6) {printf("Checking bends\n");}
    if(inter==7) {printf("Checking tors \n");}
    if(inter==8) {printf("Checking onfos\n");}
    if(inter==9) {printf("Checking ecors\n");}
    if(inter==10) {printf("Checking Uri-Bradleys\n");}
    if(inter==11) {printf("Checking free-energy bonds\n");}
    if(inter==12) {printf("Checking free-energy bends\n");}
    if(inter==13) {printf("Checking free-energy tors\n");}
    if(inter==14) {printf("Checking Watts\n");}
    if(inter==15) {printf("Checking rbar-sigma free energy potential\n");}
    if(inter==16) {printf("Checking surface potential\n");}
    printf("---------------\n\n");
    cputime(&cpu1); 
  }/* endif error check on */

    for(ip=1;ip<=pi_beads_proc;ip++){
     get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                   &(class->ghost_atoms));
   }

    if(np_beads>1){ Barrier(comm_beads);}
    test_force_pimd(class,bonded,general_data,inter,&vgen,&vgen2,&vgen3); 
    cputime(&cpu2); 
    cpu = cpu2-cpu1;
 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

#ifdef JUNK
     cpu_temp = cpu;
     vgen_temp = vgen;
     vgen2_temp = vgen2;
     vgen3_temp = vgen3;

     if(np_beads > 1){
       Barrier(comm_beads);  
       Reduce(&cpu_temp,&cpu, 1, MPI_DOUBLE, MPI_MAX, 0,comm_beads);
       Barrier(comm_beads);  
       Allreduce(&vgen_temp,&vgen, 1, MPI_DOUBLE, MPI_SUM,0, comm_beads);
       Barrier(comm_beads);  
       Allreduce(&vgen2_temp,&vgen2, 1, MPI_DOUBLE, MPI_SUM,0, comm_beads);
       Barrier(comm_beads);  
       Allreduce(&vgen3_temp,&vgen3, 1, MPI_DOUBLE, MPI_SUM,0, comm_beads);
      }/* endif */
#endif

     if(np_beads>1){
       Barrier(comm_beads);  
       communicate_test_energy_pimd( &vgen, &vgen2, &vgen3, &cpu,comm_beads);
       Barrier(comm_beads);  
     }

    if(inter==1){
      if(error_check_on == 1){
      printf("The real_space inter energy is %.13g; cputime %g\n",
                 vgen,cpu);
    }/*endif*/
                 vreal=vgen;vcoul=vgen2; vvdw=vgen3;}
    if(inter==2){
       if(error_check_on == 1){
      printf("The long range correction is %.13g; cputime %g \n",
                         vgen,cpu);
    }/*endif*/
                 vlong=vgen;}
    if(inter==3){
       if(error_check_on == 1){
      printf("The recip energy is %.13g; cputime %g\n",vgen,cpu);
    }/*endif*/
                 vrecip=vgen;}
    if(inter==4){
       if(error_check_on == 1){
      printf("The background energy is %.13g; cputime %g\n",
                         vgen,cpu);
    }/*endif*/
                 vbgr=vgen;vself=vgen2;}
    if(inter==5){
       if(error_check_on == 1){
      printf("The bond  energy is %.13g; cputime %g\n",vgen,cpu);
    }/*endif*/
                 vbond=vgen;}
    if(inter==6){
       if(error_check_on == 1){
      printf("The bend  energy is %.13g; cputime %g\n",vgen,cpu);
    }/*endif*/
                 vbend=vgen;}
    if(inter==7){
       if(error_check_on == 1){
      printf("The tors  energy is %.13g; cputime %g\n",vgen,cpu);
    }/*endif*/
                 vtors=vgen;}
    if(inter==8){
       if(error_check_on == 1){
      printf("The onfo  energy is %.13g; cputime %g\n",vgen,cpu);
    }/*endif*/
                 vonfo=vgen;vonfo_vdw=vgen2;vonfo_coul=vgen3;}
    if(inter==9){
       if(error_check_on == 1){
      printf("The ecor  energy is %.13g; cputime %g\n",vgen,cpu);
    }/*endif*/
                 vecor=vgen;}
    if(inter==10){
       if(error_check_on == 1){
      printf("The Uri-Bradley energy is %.13g; cputime %g\n",
                          vgen,cpu);
    }/*endif*/
                                    vbend_bnd=vgen;
                                    vbend_bnd_bond = vgen3;
                                    vbend_bnd_bend = vgen2;}
    if(inter==11){
       if(error_check_on == 1){
      printf("The free bond energy is %.13g; cputime %g\n",
                          vgen,cpu);
    }/*endif*/
                          vbond_free=vgen;}
    if(inter==12){
       if(error_check_on == 1){
      printf("The free bend energy is %.13g; cputime %g\n",
                          vgen,cpu);
    }/*endif*/
                          vbend_free=vgen;}
    if(inter==13){
       if(error_check_on == 1){
      printf("The free tors energy is %.13g; cputime %g\n",
                          vgen,cpu);
    }/*endif*/
                          vtors_free=vgen;}
    if(inter==14){
       if(error_check_on == 1){
           printf("The Watts energy is %.13g; cputime %g\n",
                          vgen,cpu);
       }/*endif*/
       vwatts_tot=vgen;vwatts_bond=vgen2;vwatts_bend=vgen3;break;
     }

    if(inter==15){
      if(error_check_on == 1){
        printf("The surface energy is %.13g; cputime %g\n", vgen,cpu);
      }/*endif*/
    vbar_free=vgen; break;
    }/* endif */ 

    if(inter==16){
      if(error_check_on == 1){
        printf("The Watts energy is %.13g; cputime %g\n", vgen, cpu);
      }/*endif*/
    vsurf=vgen; break;
    }/* endif */ 

  
/*---------------------------------------------------------------------------*/
/* B) Save the force and pressure tensor                                     */

   if(ifp_check == 1) {
    for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
      fx[ipart] = class->clatoms_pos[ip_check].fx[ipart]/dpi_beads; 
      fy[ipart] = class->clatoms_pos[ip_check].fy[ipart]/dpi_beads; 
      fz[ipart] = class->clatoms_pos[ip_check].fz[ipart]/dpi_beads; 
    }/*endfor*/
    for(j=1;j<=9;j++){
      pvten[j]  = general_data->ptens.pvten_tot[j];
    }/*endfor*/
   }/*endif*/

/*---------------------------------------------------------------------------*/
/* C) Get the numerical force */

   if(ifp_check == 1) {
     for(iatm=1;iatm<=2;iatm++){
      if(iatm==1){i=ipart1;}
      if(iatm==2){i=ipart2;}
/*  i) X forces */
      class->clatoms_pos[ip_check].x[i] += delta;
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_pimd(class,bonded,general_data,inter,&vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

     if(np_beads>1){
      communicate_test_energy_pimd( &vgen_p, &vgen2, &vgen3, &cpu, comm_beads);
    }
      class->clatoms_pos[ip_check].x[i] -= (2.0*delta);
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_pimd(class,bonded,general_data,inter,&vgen_m,&vgen2,&vgen3); 

/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

     if(np_beads>1){
      communicate_test_energy_pimd( &vgen_m, &vgen2, &vgen3, &cpu, comm_beads);
    }
      class->clatoms_pos[ip_check].x[i] += delta;
      fxb = (vgen_m-vgen_p)/(2.0*delta);
/*  ii) Y forces */
      class->clatoms_pos[ip_check].y[i] += delta;
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_pimd(class,bonded,general_data,inter,&vgen_p,&vgen2,&vgen3); 

/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

     if(np_beads>1){
      communicate_test_energy_pimd( &vgen_p, &vgen2, &vgen3, &cpu, comm_beads);
    }
      class->clatoms_pos[ip_check].y[i] -= (2.0*delta);
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_pimd(class,bonded,general_data,inter,&vgen_m,&vgen2,&vgen3); 

/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

     if(np_beads>1){
      communicate_test_energy_pimd( &vgen_m, &vgen2, &vgen3, &cpu, comm_beads);
    }
      class->clatoms_pos[ip_check].y[i] += delta;
      fyb = (vgen_m-vgen_p)/(2.0*delta);
/*  iii) Z forces */
      class->clatoms_pos[ip_check].z[i] += delta;
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_pimd(class,bonded,general_data,inter,&vgen_p,&vgen2,&vgen3); 

/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

     if(np_beads>1){
      communicate_test_energy_pimd( &vgen_p, &vgen2, &vgen3, &cpu, comm_beads);
    }
      class->clatoms_pos[ip_check].z[i] -= (2.0*delta);
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_pimd(class,bonded,general_data,inter,&vgen_m,&vgen2,&vgen3); 

/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

     if(np_beads>1){
      communicate_test_energy_pimd( &vgen_m, &vgen2, &vgen3, &cpu, comm_beads);
    }
      class->clatoms_pos[ip_check].z[i] += delta;
      fzb = (vgen_m-vgen_p)/(2.0*delta);
/*  iv) Print out */
      for(iproc = 0; iproc < class->communicate.np; iproc++){
        if(np_beads > 1) Barrier(comm_beads);
        if(rank == iproc){
          printf("atm %d fx_num %.13g fx %.13g\n",i,fxb,fx[i]);
          printf("atm %d fy_num %.13g fy %.13g\n",i,fyb,fy[i]);
          printf("atm %d fz_num %.13g fz %.13g\n",i,fzb,fz[i]);
        }/* endif*/ 
      }/* endfor : iproc */

    }/*endfor:iatm*/ 

/*---------------------------------------------------------------------------*/
/* D) Construct the numerical pressure tensor                                */

    cubic_box_flag = general_data->cell.cubic_box_flag;
    general_data->cell.cubic_box_flag = 0;
    for(j=1;j<=9;j++){ 
/* -----------------*/
/* i)Positive shift */
        general_data->cell.hmat[j] +=  delta;
        for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
            xmod_old[ipart] = xmod[ipart];
            ymod_old[ipart] = ymod[ipart];
            zmod_old[ipart] = zmod[ipart];
         }/*endfor:ipart*/
         for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           xmod[ipart] = sx[ipart]*general_data->cell.hmat[1]
                        +sy[ipart]*general_data->cell.hmat[4]
                        +sz[ipart]*general_data->cell.hmat[7];
           ymod[ipart] = sx[ipart]*general_data->cell.hmat[2]
                        +sy[ipart]*general_data->cell.hmat[5]
                        +sz[ipart]*general_data->cell.hmat[8];
           zmod[ipart] = sx[ipart]*general_data->cell.hmat[3]
                        +sy[ipart]*general_data->cell.hmat[6]
                        +sz[ipart]*general_data->cell.hmat[9];
        }/*endfor:ipart*/
        for(ip=1;ip<=pi_beads_proc;ip++){ 
         for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           class->clatoms_pos[ip].x[ipart] += (xmod[ipart] - xmod_old[ipart]);
           class->clatoms_pos[ip].y[ipart] += (ymod[ipart] - ymod_old[ipart]);
           class->clatoms_pos[ip].z[ipart] += (zmod[ipart] - zmod_old[ipart]);
         }/*endfor:ipart*/
        }/*endfor:ip*/
        gethinv((general_data->cell.hmat),(general_data->cell.hmati),
                                &(general_data->cell.vol),iperd);
        for(ip=1;ip<=pi_beads_proc;ip++){ 
         get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                       &(class->ghost_atoms));
        }/*endfor:ip*/
        test_force_pimd(class,bonded,general_data,inter,&vgen_p,&vgen2,
                                                                    &vgen3); 
     if(np_beads>1){
        communicate_test_energy_pimd( &vgen_p, &vgen2, &vgen3, &cpu, 
                                                           comm_beads);
      }
/* ------------------*/
/* ii)Negative shift */
        general_data->cell.hmat[j] -= (2.0*delta);
        for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
            xmod_old[ipart] = xmod[ipart];
            ymod_old[ipart] = ymod[ipart];
            zmod_old[ipart] = zmod[ipart];
         }/*endfor:ipart*/
         for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           xmod[ipart] = sx[ipart]*general_data->cell.hmat[1]
                        +sy[ipart]*general_data->cell.hmat[4]
                        +sz[ipart]*general_data->cell.hmat[7];
           ymod[ipart] = sx[ipart]*general_data->cell.hmat[2]
                        +sy[ipart]*general_data->cell.hmat[5]
                        +sz[ipart]*general_data->cell.hmat[8];
           zmod[ipart] = sx[ipart]*general_data->cell.hmat[3]
                        +sy[ipart]*general_data->cell.hmat[6]
                        +sz[ipart]*general_data->cell.hmat[9];
        }/*endfor:ipart*/
        for(ip=1;ip<=pi_beads_proc;ip++){ 
         for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           class->clatoms_pos[ip].x[ipart] += (xmod[ipart] - xmod_old[ipart]);
           class->clatoms_pos[ip].y[ipart] += (ymod[ipart] - ymod_old[ipart]);
           class->clatoms_pos[ip].z[ipart] += (zmod[ipart] - zmod_old[ipart]);
         }/*endfor:ipart*/
        }/*endfor:ip*/
        gethinv((general_data->cell.hmat),(general_data->cell.hmati),
                   &(general_data->cell.vol),iperd);
        for(ip=1;ip<=pi_beads_proc;ip++){ 
         get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                       &(class->ghost_atoms));
        }/*endfor:beads*/
        test_force_pimd(class,bonded,general_data,inter,&vgen_m,&vgen2,
                                                        &vgen3); 
     if(np_beads>1){
        communicate_test_energy_pimd( &vgen_m, &vgen2, &vgen3, &cpu, 
                                                        comm_beads);
      }
/*----------------------------------------*/
/* iii) Get derivative and put cell back  */
        general_data->cell.hmat[j]  += delta;
        hmatd[j] = (vgen_m-vgen_p)/(2.0*delta);
    }/*endfor: hmat components*/

    general_data->cell.cubic_box_flag = cubic_box_flag;
    gethinv((general_data->cell.hmat),(general_data->cell.hmati),
             &(general_data->cell.vol),iperd);
    for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
            xmod_old[ipart] = xmod[ipart];
            ymod_old[ipart] = ymod[ipart];
            zmod_old[ipart] = zmod[ipart];
    }/*endfor:ipart*/
    for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           xmod[ipart] = sx[ipart]*general_data->cell.hmat[1]
                        +sy[ipart]*general_data->cell.hmat[4]
                        +sz[ipart]*general_data->cell.hmat[7];
           ymod[ipart] = sx[ipart]*general_data->cell.hmat[2]
                        +sy[ipart]*general_data->cell.hmat[5]
                        +sz[ipart]*general_data->cell.hmat[8];
           zmod[ipart] = sx[ipart]*general_data->cell.hmat[3]
                        +sy[ipart]*general_data->cell.hmat[6]
                        +sz[ipart]*general_data->cell.hmat[9];
    }/*endfor:ipart*/
    for(ip=1;ip<=pi_beads_proc;ip++){ 
      for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           class->clatoms_pos[ip].x[ipart] += (xmod[ipart] - xmod_old[ipart]);
           class->clatoms_pos[ip].y[ipart] += (ymod[ipart] - ymod_old[ipart]);
           class->clatoms_pos[ip].z[ipart] += (zmod[ipart] - zmod_old[ipart]);
      }/*endfor:ipart*/
    }/*endfor:ip*/
    for(i=1;i<=9;i++){
     pvten[i] /= pi_beads;
    }/*endfor*/
    for(i=1;i<=3;i++){
      ioff = (i-1)*3; 
      for(j=1;j<=3;j++){
        joff = (j-1)*3;
        pvtenb = 0.0;
        for(k=1;k<=3;k++){
         koff = (k-1)*3;
         pvtenb += general_data->cell.hmat[(j+koff)]*hmatd[(i+koff)];
        }/*endfor*/
        if(inter==2&&class->energy_ctrl.iswit_vdw<=0){pvtenb*=2.0;}
       if(error_check_on==1){
        printf("P%d%d_num %.13g P%d%d %.13g\n",
                              i,j,pvtenb,i,j,pvten[(i+joff)]);
}/*endif*/
      }/*endfor*/
    }/*endfor*/     
  }/* endif ifp_check */
/*---------------------------------------------------------------------------*/
/* E) Completed test                                                         */

if(error_check_on==1){
                 printf("\n---------------\n");
    if(inter==1){printf("Finished real_space inter\n");}
    if(inter==2){printf("Finished long \n");}
    if(inter==3){printf("Finished ewald\n");}
    if(inter==4){printf("Finished bkgr \n");}
    if(inter==5){printf("Finished bonds\n");}
    if(inter==6){printf("Finished bends\n");}
    if(inter==7){printf("Finished tors \n");}
    if(inter==8){printf("Finished onfos\n");}
    if(inter==9){printf("Finished ecors\n");}
    if(inter==10){printf("Finished Uri-Bradleys\n");}
    if(inter==11){printf("Finished free bonds \n");}
    if(inter==12){printf("Finished free bends \n");}
    if(inter==13){printf("Finished free tors  \n");}
    if(inter==14){printf("Finished Watts  \n");}
    if(inter==15){printf("Finished rbar-sigma  \n");}
    if(inter==16){printf("Finished surface  \n");}
    printf("===============\n\n");
    printf("Enter an integer to continue:  ");scanf("%d",&iii);
    printf("\n");
}/* endif : error check on */ 

   if(np_beads > 1) Barrier(comm_beads); 

  }/*endfor*/ 

/*==========================================================================*/
/* III) Assign energies */

    vrecip                     += vself+vbgr+vecor;
    vreal                      += vlong+vonfo;
    vvdw                       += vlong + vonfo_vdw + vsurf;
    vcoul                      += vrecip+vonfo_coul;
    general_data->stat_avg.vintert    = vreal+vrecip;
    general_data->stat_avg.vrecip     = vrecip;
    general_data->stat_avg.vvdw       = vvdw;
    general_data->stat_avg.vsurft     = vsurf;
    general_data->stat_avg.vcoul      = vcoul;
    general_data->stat_avg.vbondt     = vbond;
    general_data->stat_avg.vbendt     = vbend;
    general_data->stat_avg.vbend_bndt = vbend_bnd;
    general_data->stat_avg.vbend_bnd_bend = vbend_bnd_bend;
    general_data->stat_avg.vbend_bnd_bond = vbend_bnd_bond;
    general_data->stat_avg.vtorst     = vtors;
    general_data->stat_avg.vbond_free = vbond_free;
    general_data->stat_avg.vbend_free = vbend_free;
    general_data->stat_avg.vtors_free = vtors_free;
    general_data->stat_avg.vbar_free  = vbar_free;
    general_data->stat_avg.vonfot     = vonfo;
    general_data->stat_avg.vintrat    = (vbond+vbend+vbend_bnd+vtors
                                         +vbond_free+vbend_free+vtors_free);
    general_data->stat_avg.vbondt_watts = vwatts_bond;
    general_data->stat_avg.vbendt_watts = vwatts_bend;
    general_data->stat_avg.vtot_watts   = vwatts_tot;

if(error_check_on==1){
    if(class->energy_ctrl.isep_vvdw == 1) {
     printf("Van der Waals energy %.13g\n",vvdw);
     printf("Coulomb energy %.13g\n",vcoul);
    }/*endif*/
}/* endif : error check on */ 

/*==========================================================================*/
/* IV) Done */

  cfree(&(fx[1]));
  cfree(&(fy[1]));
  cfree(&(fz[1]));
  cfree(&(pvten[1]));
  cfree(&(hmatd[1]));

  /*-------------------------------------------------------------------*/
}/*end routine */
/*==========================================================================*/



/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

void test_force_pimd(CLASS *class, BONDED *bonded, GENERAL_DATA *general_data,
                     int inter,double *vgen, double *vgen2, double *vgen3)

/*==========================================================================*/
{/*begin Routine */
/*==========================================================================*/
/*       Local Variables                                                    */
#include "../typ_defs/typ_mask.h"

 double vvdw,vcoul;
 double vself,vbgr,vlong,vol;
 double vonfo_vdw,vonfo_coul;
 double vbend_bnd_bond, vbend_bnd_bend;
 int ipart,j,iii,ip,iver_get,irespa,i;
 int pi_beads         = class->clatoms_info.pi_beads; 
 int pi_beads_proc    = class->clatoms_info.pi_beads_proc; 
 int error_check_on   = general_data->error_check_on;
 double pext          = general_data->statepoint.pext;
 double *pvten        = general_data->ptens.pvten;
 double *pvten_tot    = general_data->ptens.pvten_tot;
 double *clus_corr_r  = general_data->ewald.clus_corr_r;
 double *dclus_corr_r = general_data->ewald.dclus_corr_r;
 double *x, *y, *z; 
 double *fx, *fy, *fz; 
 double *fxt, *fyt, *fzt; 
 double *dx = class->ewd_scr.x;
 double *dy = class->ewd_scr.y;
 double *dz = class->ewd_scr.z;
 double *xmod = class->clatoms_info.xmod;
 double *ymod = class->clatoms_info.ymod;
 double *zmod = class->clatoms_info.zmod;
 int natm_tot = class->clatoms_info.natm_tot;
 int ires_bond = 0;
 class->energy_ctrl.iget_pv_real_inter = 1;
 class->energy_ctrl.iget_pe_real_inter = 1;

/*==========================================================================*/
/* I)  Initialize                                                           */

    iver_get =1;
    *vgen = 0.0;
    *vgen2 = 0.0;
    *vgen3 = 0.0;
    for(ip=1;ip<= pi_beads_proc;ip++){
     for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
      class->clatoms_pos[ip].fx[ipart]  = 0.0;
      class->clatoms_pos[ip].fy[ipart]  = 0.0;
      class->clatoms_pos[ip].fz[ipart]  = 0.0;
      class->clatoms_pos[ip].fxt[ipart] = 0.0;
      class->clatoms_pos[ip].fyt[ipart] = 0.0;
      class->clatoms_pos[ip].fzt[ipart] = 0.0;
     }/*endfor*/
    }/*endfor*/

    for(j=1;j<=9;j++){
      general_data->ptens.pvten[j]     = 0.0;
      general_data->ptens.pvten_tot[j] = 0.0;
    }/*endfor*/

/*==========================================================================*/
/* II)  Get energies                                                        */

    if(inter==1){
       vvdw=0.0;vcoul=0.0;
       for(ip=1;ip<=pi_beads_proc;ip++){
         force_control(&(class->clatoms_info),&(class->clatoms_pos[ip]), 
                       &(class->for_scr),
                       &(class->atommaps),&(general_data->cell),
                       &(general_data->ptens),   &(class->interact),
                       &(class->energy_ctrl),&(class->nbr_list),
                       &(bonded->excl),    &(bonded->intra_scr),vgen,
		       &vvdw,&vcoul,error_check_on,
                       &(class->class_comm_forc_pkg));
         }/*endfor*/
       vvdw/=pi_beads;
       vcoul/=pi_beads;
       *vgen/=pi_beads;
       *vgen2 = vcoul;
       *vgen3 = vvdw;
    }/*endif*/
   if(error_check_on == 1){
    if(inter==2){
       vol = general_data->cell.vol;
       if(general_data->cell.iperd==3){
          long_range_corr(pi_beads,vgen,vol,
                            &(general_data->ptens),&(class->for_scr),
                            &(class->interact),&(class->energy_ctrl),pext);

       }/*endif*/
    }/*endif*/
   }/* endif : error_check_on */

    if((class->clatoms_info.nchrg>0)&&(general_data->cell.iperd>0)
                                    &&(inter==3)){
       for(ip=1;ip<=pi_beads_proc;ip++){
        if(class->part_mesh.pme_on==0){
         ewald3d_recip(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                 &(general_data->cell),
                 &(general_data->ptens),(general_data->ewald.alp_ewd),
                 (general_data->ewald.alp_clus),
                 (general_data->ewald.nktot),(general_data->ewald.kastr),
                 (general_data->ewald.kbstr),(general_data->ewald.kcstr),
                 (general_data->ewald.ibrk1),(general_data->ewald.ibrk2),
                 &(class->ewd_scr),vgen,
                 (class->for_scr.wght_ter_res),iver_get,
                 &(class->class_comm_forc_pkg),
                 class->energy_ctrl.iget_pv_real_inter,
                 clus_corr_r,dclus_corr_r);
        }else{
         irespa = 0;
         ewald3d_recip_pme(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                     &(general_data->cell),
                     &(general_data->ptens),(general_data->ewald.alp_ewd),
                     (general_data->ewald.nktot),(general_data->ewald.kastr),
                     (general_data->ewald.kbstr),(general_data->ewald.kcstr),
                     &(class->ewd_scr),vgen,
                     (class->for_scr.wght_ter_res),iver_get,
                     &(class->part_mesh),irespa,&(class->class_comm_forc_pkg),
                     class->energy_ctrl.iget_pv_real_inter,
                     &(general_data->pme_fft_pkg),&(class->for_scr),
                     clus_corr_r,dclus_corr_r);
        }/*endif*/
       }/*endfor*/
       *vgen/=pi_beads;
    }/*endif*/
    if((class->clatoms_info.nchrg>0)&&(general_data->cell.iperd>0)
                                                          &&(inter==4)){
       vol = general_data->cell.vol;
       if(error_check_on == 1){
         ewald3d_selfbgr(&(class->clatoms_info),&general_data->ewald,
                      &(general_data->ptens),vol,
                      (bonded->intra_scr.wght_tra_res),&vself,&vbgr,
                      (class->communicate.np_forc),
                      class->energy_ctrl.iget_pv_real_inter,
                      general_data->cell.iperd);
         *vgen  = vbgr;
         *vgen2 = vself;
       }/* endif : error_check_on */
     }/*endif*/
    if((bonded->bond.npow!=0)&&(inter==5)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       bond(&(class->clatoms_info),&(class->clatoms_pos[ip]),
              &(bonded->bond),&(general_data->cell),
              &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
              ires_bond,&(class->class_comm_forc_pkg),
              class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
      *vgen /= pi_beads;
    }/*endif*/
     
    if((bonded->grp_bond_watts.num_33)!=0&&(inter==14)){
        for(ip=1;ip<=pi_beads_proc;ip++){
         bond_watts_33(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                &(bonded->grp_bond_watts),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen3,
                vgen2,vgen,iver_get,
                &(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter);
        }/*endfor*/
        *vgen /=pi_beads;
        *vgen2/=pi_beads;
        *vgen3/=pi_beads;
    }/*endif*/

    if((bonded->bend.npow!=0)&&(inter==6)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       bend(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->bend),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
      *vgen /= pi_beads;
    }/*endif*/

    if((bonded->tors.npow!=0)&&(inter==7)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       tors(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->tors),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
      *vgen /= pi_beads;
    }/*endif*/

    if((bonded->onfo.num!=0)&&(inter==8)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       onfo(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->onfo),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,
            &vonfo_vdw,&vonfo_coul,iver_get,&(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
      *vgen /= pi_beads;
    }/*endif*/

    if((bonded->ecor.num!=0)&&(inter==9)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       ecor(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->ecor),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pe_real_inter,
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
      *vgen /= pi_beads;
    }/*endif*/

    if((bonded->bend_bnd.num!=0)&&(inter==10)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       bend_bnd(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                &(bonded->bend_bnd),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                vgen2,vgen3,iver_get,&(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
      *vgen /= pi_beads;
    }/*endif*/

  if(error_check_on == 1){
    if((bonded->bond_free.num!=0)&&(inter==11)){
      bond_free_mode(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                &(bonded->bond_free),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                &(class->energy_ctrl),(class->communicate.np_forc));
    }/*endif*/
    if((bonded->bend_free.num!=0)&&(inter==12)){
      bend_free_mode(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                &(bonded->bend_free),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                &(class->energy_ctrl),(class->communicate.np_forc));
    }/*endif*/
    if((bonded->tors_free.num!=0)&&(inter==13)){
      tors_free_mode(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                &(bonded->tors_free),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                &(class->energy_ctrl),(class->communicate.np_forc));
    }/*endif*/
  }/* endif : error_check_on */

  if( (class->surface.isurf_on != 0) && (inter == 16) ){
     for(ip=1; ip<=pi_beads_proc; ip++){
       surf_pot(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                &(class->atommaps),&(class->surface),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
                &(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter,
                class->energy_ctrl.iget_pe_real_inter);
     }/*endfor*/
     *vgen /= pi_beads;
    }/*endif*/

/*==========================================================================*/
/* III) Distribute ghost forces into atom forces                            */

   for(ip=1;ip<=pi_beads_proc;ip++){
    distrib_ghost_force(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                        &(class->ghost_atoms),iver_get);
   }/*endfor*/

/*==========================================================================*/
/* IV) Fix the pressure tensor                                              */

  if(pi_beads>1){
   for(ip=1;ip<=pi_beads_proc;ip++){
     x = class->clatoms_pos[ip].x;
     y = class->clatoms_pos[ip].y;
     z = class->clatoms_pos[ip].z;
     for(i=1;i<=natm_tot;i++){
       dx[i] = x[i] - xmod[i];
       dy[i] = y[i] - ymod[i];
       dz[i] = z[i] - zmod[i];
     }/*endfor*/
     fx = class->clatoms_pos[ip].fx;
     fy = class->clatoms_pos[ip].fy;
     fz = class->clatoms_pos[ip].fz;
     fxt = class->clatoms_pos[ip].fxt;
     fyt = class->clatoms_pos[ip].fyt;
     fzt = class->clatoms_pos[ip].fzt;
     for(i=1;i<=natm_tot;i++){
      pvten[1] -= (dx[i]*fx[i]);
      pvten[5] -= (dy[i]*fy[i]);
      pvten[9] -= (dz[i]*fz[i]);
      pvten[2] -= (dx[i]*fy[i]);
      pvten[4] -= (dy[i]*fx[i]);
      pvten[3] -= (dx[i]*fz[i]);
      pvten[7] -= (dz[i]*fx[i]);
      pvten[6] -= (dy[i]*fz[i]);
      pvten[8] -= (dz[i]*fy[i]);
     }/*endfor*/
     for(i=1;i<=natm_tot;i++){
      pvten_tot[1] -= (dx[i]*fxt[i]);
      pvten_tot[5] -= (dy[i]*fyt[i]);
      pvten_tot[9] -= (dz[i]*fzt[i]);
      pvten_tot[2] -= (dx[i]*fyt[i]);
      pvten_tot[4] -= (dy[i]*fxt[i]);
      pvten_tot[3] -= (dx[i]*fzt[i]);
      pvten_tot[7] -= (dz[i]*fxt[i]);
      pvten_tot[6] -= (dy[i]*fzt[i]);
      pvten_tot[8] -= (dz[i]*fyt[i]);
     }/*endfor*/
   }/*endfor*/
  }/*endif*/

/*-------------------------------------------------------------------*/
   }/*end routine */
/*==========================================================================*/










