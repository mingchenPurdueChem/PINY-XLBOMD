/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
/*                                                                          */
/*                         PI_MD:                                           */
/*             The future of simulation technology                          */
/*             ------------------------------------                         */
/*                Module: test_energy_cp_pimd.c                             */
/*                                                                          */
/* This routine numerically checks forces and pressure tensors              */
/* generated by the energy routine                                          */
/*                                                                          */
/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

#include "standard_include.h"
#include "../typ_defs/typedefs_gen.h"
#include "../typ_defs/typedefs_cp.h"
#include "../typ_defs/typedefs_class.h"
#include "../typ_defs/typedefs_bnd.h"
#include "../proto_defs/proto_energy_ctrl_entry.h"
#include "../proto_defs/proto_energy_ctrl_local.h"
#include "../proto_defs/proto_energy_ctrl_cp_entry.h"
#include "../proto_defs/proto_energy_ctrl_cp_local.h"
#include "../proto_defs/proto_energy_cp_entry.h"
#include "../proto_defs/proto_energy_cp_local.h"
#include "../proto_defs/proto_intra_entry.h"
#include "../proto_defs/proto_intra_con_entry.h"
#include "../proto_defs/proto_surf_entry.h"
#include "../proto_defs/proto_real_space_entry.h"
#include "../proto_defs/proto_recip3d_entry.h"
#include "../proto_defs/proto_math.h"
#include "../proto_defs/proto_friend_lib_entry.h"
#include "../proto_defs/proto_communicate_wrappers.h"

#define DEBUG_OFF

/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

void test_energy_cp_pimd(CLASS *class, BONDED *bonded, 
                                 GENERAL_DATA *general_data,CP *cp)

/*==========================================================================*/
/*         Begin Routine                                                    */ 
     {/*begin routine*/
/*==========================================================================*/
/*         Local Variable declarations                                      */

#include "../typ_defs/typ_mask.h"
  
  int natm_mall = class->clatoms_info.natm_tot;
  int inter,iii,ioff,bead_flag;
  int cubic_box_flag;
  double delta,delta_cp;
  int ifp_check,ip,proc;
  int ip_check=1,ifcp_check=1;
  int iproc_check=0;
  int iperd,ninter;
  int ipart1,ipart2,ipart;
  int j,i,iatm,k,koff,joff;
  int istate,icoef,ind;
  int nmall_up,nmall_dn;
  int pi_beads = class->clatoms_info.pi_beads; 
  double vreal,vrecip,vself,vbgr,vlong;
  double vvdw,vcoul,vsurf;
  double vbond,vbend,vbend_bnd,vtors,vonfo,vonfo_vdw,vonfo_coul,vecor;
  double vwatts_bond,vwatts_bend,vwatts_tot;
  double vbend_bnd_bond, vbend_bnd_bend;
  double vbond_free,vbend_free,vtors_free,vbar_free;
  double *fx,*fy,*fz;
  double *pvten,*hmatd;
  double vgen,vgen_p,vgen_m;
  double vgen2,vgen3;
  double fxb,fyb,fzb,pvtenb,cpu2,cpu1,cpu;
  double *fcre_up,*fcim_up,*fcre_dn,*fcim_dn;
  double cp_ehart,cp_exc,cp_eext,cp_muxc;
  double cp_enl,cp_eke;
  double fcre_up_b,fcim_up_b,fcre_dn_b,fcim_dn_b;
  double **sx,**sy,**sz;
  MPI_Comm world_use;
  int error_check_on  = general_data->error_check_on;
  int pi_beads_proc   = class->clatoms_info.pi_beads_proc;
  int myid            = class->communicate.myid;
  int myid_bead       = class->communicate.myid_bead;
  int np_beads        = class->communicate.np_beads;
  int np              = class->communicate.np;
  int np_states       = class->communicate.np_states;
  MPI_Comm world       = class->communicate.world;
  MPI_Comm comm_beads  = class->communicate.comm_beads;
  double *cell_hmat    = general_data->cell.hmat;  
  double *cell_hmati   = general_data->cell.hmati;  
  double *cell_hmat_cp = general_data->cell.hmat_cp;
  double *cell_hmati_cp= general_data->cell.hmati_cp;

/*==========================================================================*/
/* 0) Check */

    if(np_states>1){
      if(myid==0){
        printf("\n@@@@@@@@@@@@@@@-ERROR-@@@@@@@@@@@@@@@@@@@\n");
        printf("Debug CP-PIMD mode only working for bead level\n");
        printf("parallelization: np %d np_beads %d\n",np,np_beads);
        printf("@@@@@@@@@@@@@@@@-ERROR-@@@@@@@@@@@@@@@@@@@\n");
        fflush(stdout);
      }/* endif */
      Finalize();
      exit(1);
   }/*endif*/
   
/*==========================================================================*/
/* I)Initialize */


  /* mal_verify(1); */

  vlong       = 0.0;
  vself       = 0.0;
  vbgr        = 0.0;   
  vecor       = 0.0;
  vrecip      = 0.0;
  vvdw        = 0.0;
  vsurf       = 0.0;
  vcoul       = 0.0;
  vreal       = 0.0;
  vbond       = 0.0;
  vbend       = 0.0;
  vbend_bnd   = 0.0;
  vbend_bnd_bond   = 0.0;
  vbend_bnd_bend   = 0.0;
  vwatts_tot  = 0.0;
  vwatts_bond = 0.0;
  vwatts_bend = 0.0;
  vtors       = 0.0;
  vonfo       = 0.0;
  vonfo_vdw   = 0.0;
  vonfo_coul  = 0.0;
  vbond_free  = 0.0;
  vbend_free  = 0.0;
  vtors_free  = 0.0;
  vbar_free   = 0.0;
  general_data->stat_avg.cp_eke   = 0.0;
  general_data->stat_avg.cp_enl   = 0.0;
  general_data->stat_avg.cp_exc   = 0.0;
  general_data->stat_avg.cp_muxc  = 0.0;
  general_data->stat_avg.cp_eext  = 0.0;
  general_data->stat_avg.cp_ehart = 0.0;
  general_data->stat_avg.vrecip   = 0.0;

  fx    = (double *)cmalloc(class->clatoms_info.natm_tot*sizeof(double))-1;
  fy    = (double *)cmalloc(class->clatoms_info.natm_tot*sizeof(double))-1;
  fz    = (double *)cmalloc(class->clatoms_info.natm_tot*sizeof(double))-1;
  sx = cmall_mat(1,pi_beads_proc,1,natm_mall);
  sy = cmall_mat(1,pi_beads_proc,1,natm_mall);
  sz = cmall_mat(1,pi_beads_proc,1,natm_mall);
  if(np>1){Barrier(world);}
  pvten = (double *)cmalloc((size_t)9*sizeof(double))-1;
  hmatd = (double *)cmalloc((size_t)9*sizeof(double))-1;
  nmall_up = cp->cpcoeffs_info.ncoef*cp->cpcoeffs_info.nstate_up;
  nmall_dn = cp->cpcoeffs_info.ncoef*cp->cpcoeffs_info.nstate_dn;
  fcre_up=(double *)cmalloc(nmall_up*sizeof(double))-1;
  fcim_up=(double *)cmalloc(nmall_up*sizeof(double))-1;
  if(cp->cpopts.cp_lsda == 1){
   fcre_dn=(double *)cmalloc(nmall_dn*sizeof(double))-1;
   fcim_dn=(double *)cmalloc(nmall_dn*sizeof(double))-1;
  }

  iperd = general_data->cell.iperd;
  gethinv((general_data->cell.hmat),(general_data->cell.hmati),
                                      &(general_data->cell.vol),iperd);
  class->for_scr.wght_ter       = 1.0;
  class->for_scr.wght_ter_res   = 1.0;
  bonded->intra_scr.wght_tra     = 1.0;
  bonded->intra_scr.wght_tra_res = 1.0;
  bonded->intra_scr.wght_ter     = 1.0;
  bonded->intra_scr.wght_ter_res = 1.0;
if(class->communicate.myid_bead<class->communicate.np_beads){
  for(ip=1;ip<= pi_beads_proc;ip++){
   for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
    sx[ip][ipart] = 
            class->clatoms_pos[ip].x[ipart]*general_data->cell.hmati[1]+       
            class->clatoms_pos[ip].y[ipart]*general_data->cell.hmati[4]+    
            class->clatoms_pos[ip].z[ipart]*general_data->cell.hmati[7];
    sy[ip][ipart] = 
            class->clatoms_pos[ip].x[ipart]*general_data->cell.hmati[2]+     
            class->clatoms_pos[ip].y[ipart]*general_data->cell.hmati[5]+
            class->clatoms_pos[ip].z[ipart]*general_data->cell.hmati[8];
    sz[ip][ipart] = 
            class->clatoms_pos[ip].x[ipart]*general_data->cell.hmati[3]+
            class->clatoms_pos[ip].y[ipart]*general_data->cell.hmati[6]+
            class->clatoms_pos[ip].z[ipart]*general_data->cell.hmati[9];
   }/*endfor:ipart*/
  }/*endfor:ip*/
}/*endif*/
if(np>1){Barrier(world);}

/*==========================================================================*/
/* II) Loop over all the interactions */

if(error_check_on==1){
 printf("Do you wish to check forces and pressure tensor?(1 or 0)\n");
 scanf("%d",&ifp_check);
 if(ifp_check == 1) {
  printf("Enter the indices of two atoms whose force you wish checked\n");
  scanf("%d %d",&ipart1,&ipart2);printf("\n");
     if(ipart1 > class->clatoms_info.natm_tot || ipart1 <= 0) {
       printf("The particle number %d you have chosen\n",ipart1);
       printf("is out of range  -- using first particle instead\n");   
      ipart1=1;
     }
     if(ipart2 > class->clatoms_info.natm_tot || ipart2 <= 0) {
       printf("The particle number %d you have chosen\n",ipart2);
       printf("is out of range  -- using last particle instead\n");   
      ipart2=class->clatoms_info.natm_tot;
     }

 if(np_beads>1){
   printf("Enter the bead number you to check\n");
   scanf("%d",&ip_check);printf("\n");
      if(ip_check > pi_beads_proc || ip_check <= 0) {
       printf("The bead number %d you have chosen\n",ip_check);
       printf("is out of range  -- using first bead instead\n");   
       ip_check=1;
     }
   printf("Enter the processor number you to perform the check\n");
   scanf("%d",&iproc_check);printf("\n");
      if(iproc_check > np_beads-1 || iproc_check < 0) {
       printf("The processor number %d you have chosen\n",iproc_check);
       printf("is out of range  -- using processor 0 instead\n");   
       iproc_check=0;
     }
 }else{
     printf("Enter the bead number to use for this check\n");
     scanf("%d",&ip_check);
     if(ip_check > pi_beads || ip_check <= 0) {
      printf("The bead number %d you have chosen\n",ip_check);
      printf("is out of range  -- using first bead instead\n");   
      ip_check=1;
     }
 }/*endif : np_beads*/

    if(cp->cpopts.cp_ptens_calc==0){
       printf("$$$$$$$$$$$$$$$$$$$$_warning_$$$$$$$$$$$$$$$$$$$$\n");    
       printf("The cp pressure tensor option is off\n");
       printf("The cp contribution to the pressure tensor will be zero\n");
       printf("$$$$$$$$$$$$$$$$$$$$_warning_$$$$$$$$$$$$$$$$$$$$\n");    
     }/*endif*/
     printf("\n");
 }/*endif ifp_check*/

}/*endif for error checking*/
if(np>1){Barrier(world);}

if(np > 1){
   Bcast(&ipart1, 1, MPI_INT, 0, world);
   Bcast(&ipart2, 1, MPI_INT, 0, world);
   Bcast(&ip_check, 1, MPI_INT, 0, world);
   Bcast(&ifp_check, 1, MPI_INT, 0, world);
   Bcast(&iproc_check, 1, MPI_INT, 0, world);
}/* endif */

  ninter = 17;
  delta = 1.e-05;
  delta_cp = 1.e-04;
  for(inter=1; inter<=ninter; inter++){

    if(inter < 17){
      world_use = comm_beads;
      bead_flag = 1;
    }else{
      world_use = world;
      bead_flag = 0;
    }/*endif*/

/*---------------------------------------------------------------------------*/
/* A) Get the true force */

if(error_check_on==1){

    printf("===============\n");
    switch(inter) {
     case 1: printf("Checking real_space inter\n");break;
     case 2: printf("Checking long\n");break;
     case 3: printf("Checking ewald\n");break;
     case 4: printf("Checking bkgr \n");break;
     case 5: printf("Checking bonds\n");break;
     case 6: printf("Checking bends\n");break;
     case 7: printf("Checking tors \n");break;
     case 8: printf("Checking onfos\n");break;
     case 9: printf("Checking ecors\n");break;
     case 10:printf("Checking Uri-Bradleys\n");break;
     case 11:printf("Checking free bonds\n");break;
     case 12:printf("Checking free bends \n");break;
     case 13:printf("Checking free tors  \n");break;
     case 14:printf("Checking watts intramolecular potential  \n");break;
     case 15:printf("Checking rbar-sigma free energy potential  \n");break;
     case 16:printf("Checking surface potential  \n");break;
     case 17:printf("Checking electronic energy\n");break;
    }
    printf("---------------\n\n");

}/*endif : error checking*/
if(np>1){Barrier(world);}

    cputime(&cpu1); 
    for(ip=1;ip<=pi_beads_proc;ip++){
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                    &(class->ghost_atoms));
    }
    test_force_cp_pimd(class,bonded,general_data,cp,inter,
                       &vgen,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

    if(np_beads > 1){
     if(bead_flag==1){
       if(myid_bead<np_beads){
         communicate_test_energy_pimd(&vgen,&vgen2,&vgen3,&cpu,world_use);
       }/*endif*/
        Barrier(comm_beads);
     }else{
       communicate_test_energy_pimd( &vgen, &vgen2,&vgen3,&cpu,world_use);
     }/*endif*/
    }/* endif */
    cputime(&cpu2); 
    cpu = cpu2-cpu1;

  if(error_check_on==1){

    switch(inter) {

     case 1: 
           printf("The real_space inter energy is %.13g; cputime %g\n",
                   vgen,cpu);
           vreal=vgen;vcoul=vgen2;vvdw=vgen3;break;
     case 2: 
           printf("The long range correction is %.13g; cputime %g \n",
                   vgen,cpu);
           vlong=vgen;break;
     case 3: 
           printf("The recip energy is %.13g; cputime %g\n",vgen,cpu);
           vrecip=vgen;break;
     case 4: 
           printf("The background energy is %.13g; cputime %g\n",
                   vgen,cpu);
           vbgr=vgen;vself=vgen2;break;
     case 5: 
           printf("The bond  energy is %.13g; cputime %g\n",vgen,cpu);
           vbond=vgen;break;
     case 6: 
           printf("The bend  energy is %.13g; cputime %g\n",vgen,cpu);
           vbend=vgen;break;
     case 7: 
           printf("The tors  energy is %.13g; cputime %g\n",vgen,cpu);
           vtors=vgen;break;
     case 8: 
           printf("The onfo  energy is %.13g; cputime %g\n",vgen,cpu);
           vonfo=vgen,vonfo_vdw=vgen2;vonfo_coul=vgen3;break;
     case 9: 
           printf("The ecor  energy is %.13g; cputime %g\n",vgen,cpu);
           vecor=vgen;break;
     case 10: 
           printf("The Uri-Bradley energy is %.13g; cputime %g\n",
                   vgen,cpu);
           vbend_bnd=vgen;vbend_bnd_bend=vgen2;
           vbend_bnd_bond=vgen3;break;
     case 11: 
           printf("The free bond energy is %.13g; cputime %g\n",
                   vgen,cpu);
           vbond_free=vgen;break;
     case 12: 
           printf("The free bend energy is %.13g; cputime %g\n",
                   vgen,cpu);
           vbend_free=vgen;break;
     case 13: 
           printf("The free tors energy is %.13g; cputime %g\n",
                   vgen,cpu);
           vtors_free=vgen;break;
     case 14: printf("The watts energy is %.13g; cputime %g\n",
                         vgen,cpu);vwatts_tot=vgen;vwatts_bond=vgen2;
                                   vwatts_bend=vgen3; break;
     case 15: printf("The rbar-sigma energy is %.13g; cputime %g\n",
                         vgen,cpu);vbar_free=vgen;break;
     case 16: printf("The surface energy is %.13g; cputime %g\n",
                         vgen,cpu);vsurf=vgen;break;
     case 17: 
           printf("The total electronic energy is %.13g; cputime %g\n",
                   vgen2,cpu);
           break;
    
     } /* end switch */
  }/*endif : error checking*/
  if(np>1){Barrier(world);}

/*---------------------------------------------------------------------------*/
/* B) Save the force and pressure tensor                                     */

   if(ifp_check == 1) {
    for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
       fx[ipart] = class->clatoms_pos[ip_check].fx[ipart]; 
       fy[ipart] = class->clatoms_pos[ip_check].fy[ipart]; 
       fz[ipart] = class->clatoms_pos[ip_check].fz[ipart]; 
    }/*endfor*/
    for(j=1;j<=9;j++){
      pvten[j]  = general_data->ptens.pvten_tot[j];
    }/*endfor*/
   }/*endif : force check*/

  if(ifcp_check == 1) {
   for(i=1;i <= nmall_up;i++){
    fcre_up[i] = cp->cpcoeffs_pos[ip_check].fcre_up[i];
    fcim_up[i] = cp->cpcoeffs_pos[ip_check].fcim_up[i];
   }/* endfor i */
   if(cp->cpopts.cp_lsda == 1){
    for(i=1;i <= nmall_dn;i++){
     fcre_dn[i] = cp->cpcoeffs_pos[ip_check].fcre_dn[i];
     fcim_dn[i] = cp->cpcoeffs_pos[ip_check].fcim_dn[i];
    }/* endfor i */
   }/* endif cp_lsda */
  }/*endif*/

/*---------------------------------------------------------------------------*/
/* C) Get the numerical force */

   if(ifp_check == 1) {
     for(iatm=1;iatm<=2;iatm++){
      if(iatm==1){i=ipart1;}
      if(iatm==2){i=ipart2;}
/*  i) X forces */
      if(myid==iproc_check) class->clatoms_pos[ip_check].x[i] += delta;
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                    &vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
        communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2, &vgen3, &cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) class->clatoms_pos[ip_check].x[i] -= (2.0*delta);
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                    &vgen_m,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) class->clatoms_pos[ip_check].x[i] += delta;
      fxb = (vgen_m-vgen_p)/(2.0*delta);
/*  ii) Y forces */
      if(myid==iproc_check) class->clatoms_pos[ip_check].y[i] += delta;
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                    &vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   } /* endif */
      if(myid==iproc_check) class->clatoms_pos[ip_check].y[i] -= (2.0*delta);
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                    &vgen_m,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd( &vgen_m, &vgen2, &vgen3, &cpu, world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) class->clatoms_pos[ip_check].y[i] += delta;
      fyb = (vgen_m-vgen_p)/(2.0*delta);
/*  iii) Z forces */
      if(myid==iproc_check) class->clatoms_pos[ip_check].z[i] += delta;
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                    &vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

  if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
  }/* endif */   
      if(myid==iproc_check) class->clatoms_pos[ip_check].z[i] -= (2.0*delta);
      get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip_check]),
                    &(class->ghost_atoms));
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                    &vgen_m,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) class->clatoms_pos[ip_check].z[i] += delta;
      fzb = (vgen_m-vgen_p)/(2.0*delta);
      fx[i]/=pi_beads;
      fy[i]/=pi_beads;
      fz[i]/=pi_beads;
/*  iv) Print out */

  if(np_beads>1){
     if(myid == iproc_check){
      printf("Processor %d printing....\n",iproc_check);      
      printf("Bead %d....\n",pi_beads_proc*class->communicate.myid+ip_check);      
      printf("atm %d fx_num %.13g fx %.13g\n",i,fxb,fx[i]);
      printf("atm %d fy_num %.13g fy %.13g\n",i,fyb,fy[i]);
      printf("atm %d fz_num %.13g fz %.13g\n",i,fzb,fz[i]);
    }/*endif for proc's*/
     Barrier(world);
  }else{
      printf("atm %d fx_num %.13g fx %.13g\n",i,fxb,fx[i]);
      printf("atm %d fy_num %.13g fy %.13g\n",i,fyb,fy[i]);
      printf("atm %d fz_num %.13g fz %.13g\n",i,fzb,fz[i]);
  }/*endif : np_beads*/

    }/*endfor:iatm*/ 


/*---------------------------------------------------------------------------*/
/* D) Construct the numerical pressure tensor                                */

    cubic_box_flag = general_data->cell.cubic_box_flag;
    general_data->cell.cubic_box_flag = 0;

    for(j=1;j<=9;j++){ 
        if(myid==iproc_check) {
             cell_hmat[j] +=  delta;
             cell_hmat_cp[j] +=  delta;
        }/* endif */
        for(ip=1;ip<= pi_beads_proc;ip++){
         for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           class->clatoms_pos[ip].x[ipart] = 
                               sx[ip][ipart]*general_data->cell.hmat[1]
                              +sy[ip][ipart]*general_data->cell.hmat[4]
                              +sz[ip][ipart]*general_data->cell.hmat[7];
           class->clatoms_pos[ip].y[ipart] = 
                               sx[ip][ipart]*general_data->cell.hmat[2]
                              +sy[ip][ipart]*general_data->cell.hmat[5]
                              +sz[ip][ipart]*general_data->cell.hmat[8];
           class->clatoms_pos[ip].z[ipart] = 
                               sx[ip][ipart]*general_data->cell.hmat[3]
                              +sy[ip][ipart]*general_data->cell.hmat[6]
                              +sz[ip][ipart]*general_data->cell.hmat[9];
         }/*endfor*/
        }/*endfor*/
        gethinv((cell_hmat),(cell_hmati),&(general_data->cell.vol),iperd);
        gethinv((cell_hmat_cp),(cell_hmati_cp),&(general_data->cell.vol_cp),iperd);
        for(ip=1;ip<= pi_beads_proc;ip++){
          get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                        &(class->ghost_atoms));
        }/*endfor*/
        test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                   &vgen_p,&vgen2,&vgen3); 

/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
        if(myid==iproc_check) {
            cell_hmat[j] -= (2.0*delta);
            cell_hmat_cp[j] -= (2.0*delta);
        }/* endif */
        for(ip=1;ip<= pi_beads_proc;ip++){
         for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
           class->clatoms_pos[ip].x[ipart] = 
                               sx[ip][ipart]*general_data->cell.hmat[1]
                              +sy[ip][ipart]*general_data->cell.hmat[4]
                              +sz[ip][ipart]*general_data->cell.hmat[7];
           class->clatoms_pos[ip].y[ipart] = 
                               sx[ip][ipart]*general_data->cell.hmat[2]
                              +sy[ip][ipart]*general_data->cell.hmat[5]
                              +sz[ip][ipart]*general_data->cell.hmat[8];
           class->clatoms_pos[ip].z[ipart] = 
                               sx[ip][ipart]*general_data->cell.hmat[3]
                              +sy[ip][ipart]*general_data->cell.hmat[6]
                              +sz[ip][ipart]*general_data->cell.hmat[9];
         }/*endfor*/
        }/*endfor*/
        gethinv((cell_hmat),(cell_hmati),&(general_data->cell.vol),iperd);
        gethinv((cell_hmat_cp),(cell_hmati_cp),&(general_data->cell.vol_cp),iperd);
        for(ip=1;ip<= pi_beads_proc;ip++){
          get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                        &(class->ghost_atoms));
        }/*endfor*/

/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                 &vgen_m,&vgen2,&vgen3); 

   if(np_beads > 1 ){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
        if(myid==iproc_check) {
            cell_hmat[j]  += delta;
            cell_hmat_cp[j]  += delta;
        }/* endif */
        hmatd[j] = (vgen_m-vgen_p)/(2.0*delta);
    }/*endfor*/

    general_data->cell.cubic_box_flag = cubic_box_flag;

    gethinv((cell_hmat),(cell_hmati),&(general_data->cell.vol),iperd);
    gethinv((cell_hmat_cp),(cell_hmati_cp),&(general_data->cell.vol_cp),iperd);
    for(i=1;i<=9;i++){
     pvten[i] /= pi_beads;
    }/*endfor*/
    for(i=1;i<=3;i++){
      ioff = (i-1)*3; 
      for(j=1;j<=3;j++){
        joff = (j-1)*3;
        pvtenb = 0.0;
        for(k=1;k<=3;k++){
         koff = (k-1)*3;
         pvtenb += general_data->cell.hmat[(j+koff)]*hmatd[(i+koff)];
        }/*endfor*/
        if(inter==2&&class->energy_ctrl.iswit_vdw<=0){pvtenb*=2.0;}
        if(error_check_on==1){
         printf("P%d%d_num %.13g P%d%d %.13g\n",
                              i,j,pvtenb,i,j,pvten[(i+joff)]);
        }/*endif for error checking*/
        if(np>1){Barrier(world);}
      }/*endfor*/
    }/*endfor*/     
  }/* endif ifp_check */
/*---------------------------------------------------------------------------*/

 if(inter==17){
  if(error_check_on==1){
   printf("Do you want to check the forces on the plane wave coeffs (1/0)\n");
   scanf("%d",&ifcp_check);
   if(ifcp_check == 1) {
     printf("Enter the coef and the state for the chosen bead proc whose force you wish checked\n");
     scanf("%d %d",&icoef,&istate);printf("\n");
     if(icoef > cp->cpcoeffs_info.ncoef || icoef <= 0) {
      printf("The plane wave coefficient number %d you have chosen\n",icoef);
      printf("is out of range  -- using first coefficient instead\n");   
      icoef=1;
     }/*endif*/
     if(istate > cp->cpcoeffs_info.nstate_up 
     || istate > cp->cpcoeffs_info.nstate_dn 
                                        || istate <= 0) {
      printf("The state number %d you have chosen\n",istate);
      printf("is out of range  -- using first state instead\n");   
      istate=1;
       }/*endif : istate*/
     }/*endif : ifcp_check*/
   }/*endif : error checking*/
  if(np>1){Barrier(world);}
  if(np_beads > 1) Bcast(&ifcp_check, 1, MPI_INT, 0, world);

if(ifcp_check == 1) {

  if(np_beads > 1){
     Bcast(&icoef, 1, MPI_INT, 0, world);
     Bcast(&istate, 1, MPI_INT, 0, world);
  } /* endif */

/* Doing real part of up states */
      ind = (istate-1)*cp->cpcoeffs_info.ncoef + icoef;
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cre_up[ind] += delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                               &vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cre_up[ind] -= 2.0*delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                &vgen_m,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cre_up[ind] += delta_cp;
      fcre_up_b = (vgen_m-vgen_p)/(2.0*delta_cp);
      fcre_up_b *= (double) pi_beads;
/* Doing imaginary part of up states */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cim_up[ind] += delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                   &vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cim_up[ind] -= 2.0*delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                              &vgen_m,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cim_up[ind] += delta_cp;
      fcim_up_b = (vgen_m-vgen_p)/(2.0*delta_cp);
      fcim_up_b *= (double) pi_beads;;

/*  i) Print out */

  if(np_beads>1){
     if(class->communicate.myid == iproc_check){
      printf("Processor %d printing....\n",iproc_check);      
      printf("Bead %d....\n",pi_beads_proc*class->communicate.myid+ip_check);      
      printf("coef,state %d %d fcre_up_num %.13g fcre_up %.13g\n",
             icoef,istate,fcre_up_b,fcre_up[ind]);
      printf("coef,state %d %d fcim_up_num %.13g fcim_up %.13g\n",
             icoef,istate,fcim_up_b,fcim_up[ind]);
     }/*endif for proc's*/
     Barrier(world);
  }else{
      printf("coef,state %d %d fcre_up_num %.13g fcre_up %.13g\n",
             icoef,istate,fcre_up_b,fcre_up[ind]);
      printf("coef,state %d %d fcim_up_num %.13g fcim_up %.13g\n",
             icoef,istate,fcim_up_b,fcim_up[ind]);
  }/*endif*/

/* Doing real part of dn states */
     if(cp->cpopts.cp_lsda == 1){
      ind = (istate-1)*cp->cpcoeffs_info.ncoef + icoef;
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cre_dn[ind] += delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                           &vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3, &cpu, world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cre_dn[ind] -= 2.0*delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                                    &vgen_m,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cre_dn[ind] += delta_cp;
      fcre_dn_b = (vgen_m-vgen_p)/(2.0*delta_cp);
      fcre_dn_b *= (double) pi_beads;
/* Doing imaginary part of dn states */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cim_dn[ind] += delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                            &vgen_p,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_p,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   }/* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cim_dn[ind] -= 2.0*delta_cp;
      test_force_cp_pimd(class,bonded,general_data,cp,inter,
                                              &vgen_m,&vgen2,&vgen3); 
/*---------------------------------------------------------------------------*/
/* CC) Get reduced quantities from all processors                            */

   if(np_beads > 1){
    if(bead_flag==1){
      if(myid_bead<np_beads){
       communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
      }/*endif*/
      Barrier(comm_beads);
    }else{
      communicate_test_energy_pimd(&vgen_m,&vgen2,&vgen3,&cpu,world_use);
    }/*endif*/
   } /* endif */
      if(myid==iproc_check) cp->cpcoeffs_pos[ip_check].cim_dn[ind] += delta_cp;
      fcim_dn_b = (vgen_m-vgen_p)/(2.0*delta_cp);
      fcim_dn_b *= (double) pi_beads;

/*  i) Print out */

  if(np_beads>1){
    for(proc=0;proc < class->communicate.np;proc++){
     if(class->communicate.myid == proc){
      printf("Processor %d printing....\n",proc);      
      printf("Bead %d....\n",pi_beads*class->communicate.myid+ip_check);      
      printf("coef,state %d %d fcre_dn_num %.13g fcre_dn %.13g\n",
             icoef,istate,fcre_up_b,fcre_up[ind]);
      printf("coef,state %d %d fcim_dn_num %.13g fcim_dn %.13g\n",
             icoef,istate,fcim_dn_b,fcim_dn[ind]);
     }/*endif for proc's*/
     Barrier(world);
    }/*endfor for processors*/     
  }else{
      printf("coef,state %d %d fcre_dn_num %.13g fcre_dn %.13g\n",
             icoef,istate,fcre_up_b,fcre_up[ind]);
      printf("coef,state %d %d fcim_dn_num %.13g fcim_dn %.13g\n",
             icoef,istate,fcim_dn_b,fcim_dn[ind]);
  }/*endif : np_beads*/

    }/* endif cp_lsda */

   }/*endif:ifcp_check*/
  }/*endif:CP time is here*/
/*---------------------------------------------------------------------------*/
/* F) Completed test                                                         */
  
if(error_check_on==1){

                 printf("\n---------------\n");
    switch(inter) {
     case 1:  printf("Finished real_space inter\n"); break;
     case 2:  printf("Finished long \n"); break;
     case 3:  printf("Finished ewald\n"); break;
     case 4:  printf("Finished bkgr \n"); break;
     case 5:  printf("Finished bonds\n"); break;
     case 6:  printf("Finished bends\n"); break;
     case 7:  printf("Finished tors \n"); break;
     case 8:  printf("Finished onfos\n"); break;
     case 9:  printf("Finished ecors\n"); break;
     case 10: printf("Finished Uri-Bradleys\n"); break;
     case 11: printf("Finished free bonds \n"); break;
     case 12: printf("Finished free bends \n");break;
     case 13: printf("Finished free tors  \n");break;
     case 14: printf("Finished Watts bonds  \n");break;
     case 15: printf("Finished rbar-sigma free \n");break;
     case 16: printf("Finished surface \n");break;
     case 17: printf("Finished electronic energy\n"); break;
    }/* end switch */
  }/*endif : error checking*/

  if(np>1){Barrier(world);}
  if(error_check_on==1){
    printf("===============\n\n");
    fflush(stdout);
    printf("Enter an integer to continue:  ");fflush(stdout);
    scanf("%d",&iii);
    printf("\n");
  }/*endif : error checking*/
  if(np>1){Barrier(world);}
/*==========================================================================*/
 
  }/*endfor:inter*/ 

/*==========================================================================*/
/* III) Assign energies */

    vrecip                     += vself+vbgr+vecor;
    vreal                      += vlong+vonfo;
    vvdw                       += vlong + vonfo_vdw + vsurf;
    vcoul                      += vrecip+vonfo_coul;
    general_data->stat_avg.vintert    = vreal+vrecip;
    general_data->stat_avg.vrecip     = vrecip;
    general_data->stat_avg.vvdw       = vvdw;
    general_data->stat_avg.vsurft     = vsurf;
    general_data->stat_avg.vcoul      = vcoul;
    general_data->stat_avg.vbondt     = vbond;
    general_data->stat_avg.vbendt     = vbend;
    general_data->stat_avg.vbend_bndt = vbend_bnd;
    general_data->stat_avg.vbend_bnd_bend = vbend_bnd_bend;
    general_data->stat_avg.vbend_bnd_bond = vbend_bnd_bond;
    general_data->stat_avg.vtorst     = vtors;
    general_data->stat_avg.vbond_free = vbond_free;
    general_data->stat_avg.vbend_free = vbend_free;
    general_data->stat_avg.vtors_free = vtors_free;
    general_data->stat_avg.vonfot     = vonfo;
    general_data->stat_avg.vintrat    = (vbond+vbend+vbend_bnd+vtors
				   +vbond_free+vbend_free+vtors_free);
    general_data->stat_avg.vbondt_watts = vwatts_bond;
    general_data->stat_avg.vbendt_watts = vwatts_bend;
    general_data->stat_avg.vtot_watts   = vwatts_tot;


/*==========================================================================*/
/* IV) Done */

  cfree(&(fx[1]));
  cfree(&(fy[1]));
  cfree(&(fz[1]));
  cfree(&(fcre_up[1]));
  cfree(&(fcim_up[1]));
  if(cp->cpopts.cp_lsda == 1){
   cfree(&(fcre_dn[1]));
   cfree(&(fcim_dn[1]));
  }
  cfree(&(pvten[1]));
  cfree(&(hmatd[1]));

  /*-------------------------------------------------------------------*/
    }/*end routine */
/*==========================================================================*/




/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

void test_force_cp_pimd(CLASS *class, BONDED *bonded, 
                        GENERAL_DATA *general_data,CP *cp, int inter,
                        double *vgen, double *vgen2, double *vgen3 )

/*==========================================================================*/
{/*begin Routine */
/*==========================================================================*/
/*       Local Variables                                                    */

#include "../typ_defs/typ_mask.h"

 double vvdw,vcoul;
 double vself,vbgr,vlong,vol;
 int ipart,j,iii,ip,iver_get;
 int pi_beads = class->clatoms_info.pi_beads; 
 int pi_beads_proc = class->clatoms_info.pi_beads_proc; 
 int error_check_on = general_data->error_check_on;
 double pext = general_data->statepoint.pext;
 double vgen_tmp,vgen_ret;
 int ires_bond = 0;
 MPI_Comm world = class->communicate.world;
 MPI_Comm comm_beads = class->communicate.comm_beads;
 int iperd = general_data->cell.iperd;
 int np_beads  = cp->communicate.np_beads;
 int np        = cp->communicate.np;
 int myid = cp->communicate.myid;
 double eke_tmp,enl_tmp,exc_tmp,eext_tmp,ehart_tmp,vrecip_tmp;

 class->energy_ctrl.iget_pv_real_inter = 1;
 class->energy_ctrl.iget_pe_real_inter = 1;

/*==========================================================================*/

    iver_get = 0;
    *vgen  = 0.0;
    *vgen2 = 0.0;
    *vgen3 = 0.0;
    for(ip=1;ip<= pi_beads_proc;ip++){
     for(ipart=1;ipart<= class->clatoms_info.natm_tot;ipart++){
       class->clatoms_pos[ip].fx[ipart] = 0.0;
       class->clatoms_pos[ip].fy[ipart] = 0.0;
       class->clatoms_pos[ip].fz[ipart] = 0.0;
     }/*endfor*/
    }/*endfor*/

    for(j=1;j<=9;j++){
      general_data->ptens.pvten[j]     = 0.0;
      general_data->ptens.pvten_tot[j] = 0.0;
    }/*endfor*/
    if(inter==1){
       vvdw=0.0;vcoul=0.0;
       for(ip=1;ip<= pi_beads_proc;ip++){
         force_control(&(class->clatoms_info),&(class->clatoms_pos[ip]), 
                    &(class->for_scr),
                    &(class->atommaps),&(general_data->cell),
                    &(general_data->ptens),   &(class->interact),
                    &(class->energy_ctrl),&(class->nbr_list),
                    &(bonded->excl),    &(bonded->intra_scr),vgen,
		    &vvdw,&vcoul,error_check_on,&class->class_comm_forc_pkg);
       }/*endfor*/
       vvdw/=pi_beads;
       vcoul/=pi_beads;
       *vgen/=pi_beads;
       *vgen2 = vcoul;
       *vgen3 = vvdw;
    }/*endif*/
    if(inter==2){
     vol = general_data->cell.vol;
     if(error_check_on==1){
       if(iperd==3){
         long_range_corr(pi_beads,vgen,vol,
                           &(general_data->ptens),&(class->for_scr),
                           &(class->interact),&(class->energy_ctrl),pext);

       }/*endif*/
     }/*endif*/
    }/*endif*/
    if(np>1){Barrier(world);}

    if((class->clatoms_info.nchrg>0)&&(iperd==3)&&(inter==4)){
       vol = general_data->cell.vol;
     if(error_check_on==1){
       ewald3d_selfbgr_cp(&(class->clatoms_info),&general_data->ewald,
                          &(general_data->ptens),vol,&vself,&vbgr,iperd);
       *vgen  = vbgr;
       *vgen2 = vself;
     }/*endif*/
     if(np>1){Barrier(world);}
   }/*endif*/
    if((bonded->bond.npow!=0)&&(inter==5)){
      for(ip=1;ip<=pi_beads_proc;ip++){
        bond(&(class->clatoms_info),&(class->clatoms_pos[ip]),
              &(bonded->bond),&(general_data->cell),
              &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
              ires_bond,&(class->class_comm_forc_pkg),
              class->energy_ctrl.iget_pv_real_inter);      
        }/*endfor*/
    }/*endif*/
     
    if((bonded->bend.npow!=0)&&(inter==6)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       bend(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->bend),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
    }/*endif*/

    if((bonded->tors.npow!=0)&&(inter==7)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       tors(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->tors),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
    }/*endif*/

    if((bonded->onfo.num!=0)&&(inter==8)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       onfo(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->onfo),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),
            vgen,vgen2,vgen3,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
    }/*endif*/

    if((bonded->ecor.num!=0)&&(inter==9)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       ecor(&(class->clatoms_info),&(class->clatoms_pos[ip]),
            &(bonded->ecor),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pe_real_inter,
            class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
    }/*endif*/

    if((bonded->bend_bnd.num!=0)&&(inter==10)){
      for(ip=1;ip<=pi_beads_proc;ip++){
       bend_bnd(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                &(bonded->bend_bnd),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,vgen2,vgen3,
                iver_get,&(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter);
      }/*endfor*/
    }/*endif*/
  if(error_check_on==1){
    if((bonded->bond_free.num!=0)&&(inter==11)){
      bond_free_mode(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                     &(bonded->bond_free),&(general_data->cell),
                     &(bonded->intra_scr),&(general_data->ptens),vgen,
                     &(class->energy_ctrl),
                     class->communicate.np_forc);
    }/*endif*/
    if((bonded->bend_free.num!=0)&&(inter==12)){
      bend_free_mode(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                     &(bonded->bend_free),&(general_data->cell),
                     &(bonded->intra_scr),&(general_data->ptens),vgen,
                     &(class->energy_ctrl),
                     class->communicate.np_forc);
    }/*endif*/
    if((bonded->tors_free.num!=0)&&(inter==13)){
      tors_free_mode(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                     &(bonded->tors_free),&(general_data->cell),
                     &(bonded->intra_scr),&(general_data->ptens),vgen,
                     &(class->energy_ctrl),
                     class->communicate.np_forc);
    }/*endif*/
  }/*endif : error checking*/

    if((bonded->grp_bond_watts.num_33)!=0&&(inter==14)){
        for(ip=1;ip<=pi_beads_proc;ip++){
         bond_watts_33(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                &(bonded->grp_bond_watts),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen3,
                vgen2,vgen,iver_get,
                &(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter);
        }/*endfor*/
        *vgen /=pi_beads;
        *vgen2/=pi_beads;
        *vgen3/=pi_beads;
    }/*endif*/

  if( (class->surface.isurf_on != 0) && (inter == 16) ){
     for(ip=1; ip<=pi_beads_proc; ip++){
       surf_pot(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                &(class->atommaps),&(class->surface),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
                &(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter,
                class->energy_ctrl.iget_pe_real_inter);
     }/*endfor*/
     *vgen /= pi_beads;
    }/*endif*/

   if(np>1){Barrier(world);}
   if(inter == 17){
      general_data->stat_avg.cp_ehart = 0.0;
      general_data->stat_avg.cp_exc   = 0.0;
      general_data->stat_avg.cp_muxc  = 0.0;
      general_data->stat_avg.cp_eext  = 0.0;
      general_data->stat_avg.cp_enl   = 0.0;
      general_data->stat_avg.cp_eke   = 0.0;
      general_data->stat_avg.vrecip   = 0.0;
      for(ip=1;ip<=pi_beads_proc;ip++){
       cp_ks_energy_ctrl(cp,ip,&(general_data->ewald),&(class->ewd_scr),
                           &(general_data->cell),
                           &(class->clatoms_info),
                           &(class->clatoms_pos[ip]),
                           &(class->atommaps),&(general_data->stat_avg),
                           &(general_data->ptens),
                           &(general_data->simopts),
                           &(class->for_scr));
      }/*endfor*/
      general_data->stat_avg.cp_eke   /= pi_beads;
      general_data->stat_avg.cp_enl   /= pi_beads;
      general_data->stat_avg.cp_exc   /= pi_beads;
      general_data->stat_avg.cp_muxc  /= pi_beads;
      general_data->stat_avg.cp_eext  /= pi_beads;
      general_data->stat_avg.cp_ehart /= pi_beads;
      general_data->stat_avg.vrecip   /= pi_beads;

#ifdef DEBUG
    if(np > 1){
     eke_tmp    = general_data->stat_avg.cp_eke;
     enl_tmp    = general_data->stat_avg.cp_enl;
     exc_tmp    = general_data->stat_avg.cp_exc;
     eext_tmp   = general_data->stat_avg.cp_eext;
     ehart_tmp  = general_data->stat_avg.cp_ehart;
     vrecip_tmp = general_data->stat_avg.vrecip;
     Reduce(&eke_tmp,&(general_data->stat_avg.cp_eke),1,MPI_DOUBLE, MPI_SUM,0, world);   
     Reduce(&enl_tmp,&(general_data->stat_avg.cp_enl),1,MPI_DOUBLE, MPI_SUM,0, world);   
     Reduce(&exc_tmp,&(general_data->stat_avg.cp_exc),1,MPI_DOUBLE, MPI_SUM,0, world);
     Reduce(&eext_tmp,&(general_data->stat_avg.cp_eext),1,MPI_DOUBLE, MPI_SUM,0, world);
     Reduce(&ehart_tmp,&(general_data->stat_avg.cp_ehart),1,MPI_DOUBLE, MPI_SUM,0, world);
     Reduce(&vrecip_tmp,&(general_data->stat_avg.vrecip),1,MPI_DOUBLE, MPI_SUM,0, world);
    }/* endif np_beads */    
    if(myid==0){
      printf("eke,enl,exc,eext,ehart,vrecip %.12g %.12g %.12g %.12g %.12g %.12g\n",
              general_data->stat_avg.cp_eke,
              general_data->stat_avg.cp_enl,
              general_data->stat_avg.cp_exc ,
              general_data->stat_avg.cp_eext ,
              general_data->stat_avg.cp_ehart, 
              general_data->stat_avg.vrecip);
    }/* endif myid */
#endif             

      *vgen2 = general_data->stat_avg.cp_ehart
              + general_data->stat_avg.cp_exc
              + general_data->stat_avg.cp_eext
              + general_data->stat_avg.cp_enl
              + general_data->stat_avg.cp_eke;
        *vgen = *vgen2 + general_data->stat_avg.vrecip;
   }/*endif*/

/*==========================================================================*/
/* Distribute ghost forces into atom forces                            */

   for(ip=1;ip<=pi_beads_proc;ip++){
    distrib_ghost_force(&(class->clatoms_info),&(class->clatoms_pos[ip]),
                        &(class->ghost_atoms),iver_get);
   }/*endfor*/

  /*-------------------------------------------------------------------*/
}/*end routine */
/*==========================================================================*/














