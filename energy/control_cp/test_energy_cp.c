/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/
/*                                                                          */
/*                         PI_MD:                                           */
/*             The future of simulation technology                          */
/*             ------------------------------------                         */
/*                   Module: test_energy_cp.c                               */
/*                                                                          */
/* This routine numerically checks forces and pressure tensors              */
/* generated by the energy routine                                          */
/*                                                                          */
/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/


#include "standard_include.h"
#include "../typ_defs/typedefs_gen.h"
#include "../typ_defs/typedefs_cp.h"
#include "../typ_defs/typedefs_class.h"
#include "../typ_defs/typedefs_bnd.h"
#include "../proto_defs/proto_communicate_wrappers.h"
#include "../proto_defs/proto_energy_ctrl_entry.h"
#include "../proto_defs/proto_energy_ctrl_local.h"
#include "../proto_defs/proto_energy_ctrl_cp_entry.h"
#include "../proto_defs/proto_energy_ctrl_cp_local.h"
#include "../proto_defs/proto_energy_cp_entry.h"
#include "../proto_defs/proto_energy_cp_local.h"
#include "../proto_defs/proto_intra_entry.h"
#include "../proto_defs/proto_intra_con_entry.h"
#include "../proto_defs/proto_real_space_entry.h"
#include "../proto_defs/proto_surf_entry.h"
#include "../proto_defs/proto_recip3d_entry.h"
#include "../proto_defs/proto_math.h"
#include "../proto_defs/proto_friend_lib_entry.h"

#define DEBUG_CP

/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

void test_energy_cp(CLASS *class, BONDED *bonded, 
                    GENERAL_DATA *general_data,CP *cp)

/*==========================================================================*/
/*         Begin Routine                                                    */ 
     {/*begin routine*/
/*==========================================================================*/
/*         Local Variable declarations                                      */
  
#include "../typ_defs/typ_mask.h"

  int inter,iii,ioff;
  int ifp_check,ip;
  int ihess_check=0;
  int cubic_box_flag;
  int ipart1,ipart2,ipart;
  int ipart1_h,ipart2_h;
  int j,i,iatm,k,koff,joff;
  int istate,icoef,ind,icoef_orig;
  int hess_ind;
  double fcre_up_now,fcim_up_now;
  double fcre_dn_now,fcim_dn_now;
  int nmall_up,nmall_dn;
  double vreal,vrecip,vself,vbgr,vlong;
  double vvdw,vcoul,vsurf;
  double vbond,vbend,vbend_bnd,vtors,vonfo,vonfo_vdw,vonfo_coul,vecor;
  double vbend_bnd_bond, vbend_bnd_bend;
  double vbond_free,vbend_free,vtors_free,vbar_free;
  double vwatts_tot,vwatts_bond,vwatts_bend;
  double *fx,*fy,*fz;
  double *sx,*sy,*sz;
  double *hess;
  double hxxb,hyxb,hzxb,hyyb,hzyb,hzzb;
  double *pvten,*hmatd;
  double vgen,vgen_p,vgen_m;
  double vgen2,vgen3;
  double fpx,fpy,fpz,fmx,fmy,fmz;
  double fxb,fyb,fzb,pvtenb,cpu2,cpu1,cpu;
  double *fcre_up,*fcim_up,*fcre_dn,*fcim_dn;
  double cp_ehart,cp_exc,cp_eext,cp_muxc;
  double cp_enl,cp_eke;
  double fcre_up_b,fcim_up_b,fcre_dn_b,fcim_dn_b;
/* Local constants */
  int ninter         = 17;
  double delta       = 1.e-5;
  double delta_cp    = 1.e-5;
  double delta_h     = 1.e-5;
  int ip_check=1;

/* Local pointers */

  int natm_mall        = class->clatoms_info.natm_tot;
  int natm_tot         = class->clatoms_info.natm_tot;
  double *cell_hmat    = general_data->cell.hmat;  
  double *cell_hmati   = general_data->cell.hmati;  
  double *cell_hmat_cp = general_data->cell.hmat_cp;
  double *cell_hmati_cp= general_data->cell.hmati_cp;
  int iperd            = general_data->cell.iperd;
  double *clatoms_fx   = class->clatoms_pos[1].fx;
  double *clatoms_fy   = class->clatoms_pos[1].fy;
  double *clatoms_fz   = class->clatoms_pos[1].fz;
  double *clatoms_x    = class->clatoms_pos[1].x;
  double *clatoms_y    = class->clatoms_pos[1].y;
  double *clatoms_z    = class->clatoms_pos[1].z;
  double *hess_xx      = class->clatoms_pos[1].hess_xx;
  double *hess_xy      = class->clatoms_pos[1].hess_xy;
  double *hess_xz      = class->clatoms_pos[1].hess_xz;
  double *hess_yy      = class->clatoms_pos[1].hess_yy;
  double *hess_yz      = class->clatoms_pos[1].hess_yz;
  double *hess_zz      = class->clatoms_pos[1].hess_zz;
  int ncoef            = cp->cpcoeffs_info.ncoef;
  int nstate_up_proc   = cp->cpcoeffs_info.nstate_up_proc;
  int nstate_dn_proc   = cp->cpcoeffs_info.nstate_dn_proc;
  int nstate_up        = cp->cpcoeffs_info.nstate_up;
  int nstate_dn        = cp->cpcoeffs_info.nstate_dn;
  int icoef_up_st      = cp->cpcoeffs_info.icoef_start_up;
  int icoef_dn_st      = cp->cpcoeffs_info.icoef_start_dn;
  int cp_lsda          = cp->cpopts.cp_lsda;
  int atm_hess_calc    = class->clatoms_info.hess_calc;
  double alp_ewd       = general_data->ewald.alp_ewd;
  double *ptens_pvten_tot = general_data->ptens.pvten_tot;
  double *cpcoeffs_fcre_up = cp->cpcoeffs_pos[1].fcre_up;
  double *cpcoeffs_fcim_up = cp->cpcoeffs_pos[1].fcim_up;
  double *cpcoeffs_fcre_dn = cp->cpcoeffs_pos[1].fcre_dn;
  double *cpcoeffs_fcim_dn = cp->cpcoeffs_pos[1].fcim_dn;
  double *cpcoeffs_cre_up = cp->cpcoeffs_pos[1].cre_up;
  double *cpcoeffs_cim_up = cp->cpcoeffs_pos[1].cim_up;
  double *cpcoeffs_cre_dn = cp->cpcoeffs_pos[1].cre_dn;
  double *cpcoeffs_cim_dn = cp->cpcoeffs_pos[1].cim_dn;
  int myid_state          = class->communicate.myid_state;  
  int myid                = class->communicate.myid; 
  MPI_Comm comm_states    = class->communicate.comm_states;
  MPI_Comm world          = class->communicate.world;
  int num_proc            = class->communicate.np;
  int np_states            = class->communicate.np_states;
  int nstate_ncoef_proc_max_up = cp->cpcoeffs_info.nstate_ncoef_proc_max_up;
  int nstate_ncoef_proc_max_dn = cp->cpcoeffs_info.nstate_ncoef_proc_max_dn;
  int nstate_ncoef_proc_up = cp->cpcoeffs_info.nstate_ncoef_proc_up;
  int nstate_ncoef_proc_dn = cp->cpcoeffs_info.nstate_ncoef_proc_dn;
  int icoef_up_end,icoef_dn_end;

  icoef_up_end = icoef_up_st + nstate_ncoef_proc_up;
  icoef_dn_end = icoef_dn_st + nstate_ncoef_proc_up;
  if(np_states==0){
    nstate_ncoef_proc_max_up  = ncoef;
    nstate_ncoef_proc_max_dn  = ncoef;
    icoef_up_st  = 1;
    icoef_dn_st  = 1;
    icoef_up_end = ncoef;
    icoef_dn_end = ncoef;
  }/*endif*/

/*==========================================================================*/
/* I) Initialize and Malloc  Particles */

  vlong       = 0.0;
  vself       = 0.0;
  vbgr        = 0.0;   
  vecor       = 0.0;
  vrecip      = 0.0;
  vvdw        = 0.0;
  vsurf       = 0.0;
  vcoul       = 0.0;
  vreal       = 0.0;
  vbond       = 0.0;
  vbend       = 0.0;
  vbend_bnd   = 0.0;
  vbend_bnd_bond   = 0.0;
  vbend_bnd_bend   = 0.0;
  vtors       = 0.0;
  vonfo       = 0.0;
  vonfo_vdw   = 0.0;
  vonfo_coul  = 0.0;
  vbond_free  = 0.0;
  vbend_free  = 0.0;
  vtors_free  = 0.0;
  vbar_free   = 0.0;
  general_data->stat_avg.cp_eke   = 0.0;
  general_data->stat_avg.cp_enl   = 0.0;
  general_data->stat_avg.cp_exc   = 0.0;
  general_data->stat_avg.cp_muxc  = 0.0;
  general_data->stat_avg.cp_eext  = 0.0;
  general_data->stat_avg.cp_ehart = 0.0;
  if(num_proc>1){Barrier(comm_states);}
  if(myid_state==0){
   fx    = (double *)cmalloc(natm_mall*sizeof(double))-1;
   fy    = (double *)cmalloc(natm_mall*sizeof(double))-1;
   fz    = (double *)cmalloc(natm_mall*sizeof(double))-1;
   hess  = (double *)cmalloc(6*sizeof(double))-1;
  }/*endif*/
  if(num_proc>1){Barrier(comm_states);}
  sx    = (double *)cmalloc(natm_mall*sizeof(double))-1;
  sy    = (double *)cmalloc(natm_mall*sizeof(double))-1;
  sz    = (double *)cmalloc(natm_mall*sizeof(double))-1;

/*==========================================================================*/
/* II) Malloc CP states */

  nmall_up = ncoef*nstate_up_proc;
  fcre_up=(double *)cmalloc(nmall_up*sizeof(double))-1;
  fcim_up=(double *)cmalloc(nmall_up*sizeof(double))-1;
  if(cp_lsda == 1 && nstate_dn_proc != 0){
   nmall_dn = ncoef*nstate_dn_proc;
   fcre_dn=(double *)cmalloc(nmall_dn*sizeof(double))-1;
   fcim_dn=(double *)cmalloc(nmall_dn*sizeof(double))-1;
  }/*endif*/

/*==========================================================================*/
/* III) Malloc pressure stuff */

   pvten = (double *)cmalloc(9*sizeof(double))-1;
   hmatd = (double *)cmalloc(9*sizeof(double))-1;

/*==========================================================================*/
/* IV) Initialize cell and scaled particle positions                        */

   gethinv((cell_hmat),(cell_hmati),&(general_data->cell.vol),iperd);
   for(ipart=1;ipart<= natm_tot;ipart++){
    sx[ipart] = clatoms_x[ipart]*cell_hmati[1]+       
                clatoms_y[ipart]*cell_hmati[4]+    
                clatoms_z[ipart]*cell_hmati[7];
    sy[ipart] = clatoms_x[ipart]*cell_hmati[2]+     
                clatoms_y[ipart]*cell_hmati[5]+
                clatoms_z[ipart]*cell_hmati[8];
    sz[ipart] = clatoms_x[ipart]*cell_hmati[3]+
                clatoms_y[ipart]*cell_hmati[6]+
                clatoms_z[ipart]*cell_hmati[9];
   }/*endfor*/

/*==========================================================================*/
/* III) Force checking information                                          */

 if(num_proc>1){Barrier(comm_states);}
 if(myid_state==0){
  printf("Do you wish to check forces and pressure tensor? (1 or 0)\n");
  scanf("%d",&ifp_check);

  if(ifp_check == 1) {
   printf("Enter the indices of two atoms whose force you wish checked\n");
   scanf("%d %d",&ipart1,&ipart2);printf("\n"); 
     if(ipart1 > natm_tot || ipart1 <= 0) {
      printf("The particle number %d you have chosen\n",ipart1);
      printf("is out of range  -- using first particle instead\n");   
      ipart1=1;
     }/*endif*/
     if(ipart2 > natm_tot || ipart2 <= 0) {
      printf("The particle number %d you have chosen\n",ipart2);
      printf("is out of range  -- using last particle instead\n");   
      ipart2=natm_tot;
     }/*endif*/
 }/*endif:check force*/

  if(atm_hess_calc == 3){
   printf("Do you wish to check the hessian elements? (1 or 0)\n");
   scanf("%d",&ihess_check);
   if(ihess_check == 1){
     printf("Enter the particle indices of the element you wish checked\n");
     scanf("%d %d",&ipart1_h,&ipart2_h);printf("\n");
      if(ipart1_h > natm_tot || ipart1_h <= 0) {
       printf("The particle number %d you have chosen\n",ipart1_h);
       printf("is out of range  -- using first particle instead\n");   
       ipart1_h=1;
      }/*endif*/
      if(ipart2_h > natm_tot || ipart2_h <= 0) {
       printf("The particle number %d you have chosen\n",ipart2_h);
       printf("is out of range  -- using last particle instead\n");   
       ipart2_h=natm_tot;
      }/*endif*/
    }/* endif: hessian check */
  }/* endif hess calc on */

 }/*endif:myid_state*/
 if(num_proc>1){Barrier(comm_states);}

 if(num_proc>1){
   Bcast(&(ifp_check),1,MPI_INT,0,comm_states);
   Bcast(&(ihess_check),1,MPI_INT,0,comm_states);
   Bcast(&(ipart1),1,MPI_INT,0,comm_states);
   Bcast(&(ipart2),1,MPI_INT,0,comm_states);
   Bcast(&(ipart1_h),1,MPI_INT,0,comm_states);
   Bcast(&(ipart2_h),1,MPI_INT,0,comm_states);
 }/*endif*/

/*==========================================================================*/
/* IV) Loop over all the interactions */


  for(inter=1;inter<=ninter;inter++){

/*---------------------------------------------------------------------------*/
/* A) Get the true force */

    if(num_proc>1){Barrier(comm_states);}
    fflush(stdout);
    if(myid_state==0){
     printf("===============\n");fflush(stdout);
     switch(inter) {
      case 1: printf("Checking real_space inter\n");break;
      case 2: printf("Checking long\n");break;
      case 4: printf("Checking bkgr \n");break;
      case 5: printf("Checking bonds\n");break;
      case 6: printf("Checking bends\n");break;
      case 7: printf("Checking tors \n");break;
      case 8: printf("Checking onfos\n");break;
      case 9: printf("Checking ecors\n");break;
      case 10:printf("Checking Uri-Bradleys\n");break;
      case 11:printf("Checking free bonds\n");break;
      case 12:printf("Checking free bends \n");break;
      case 13:printf("Checking free tors  \n");break;
      case 14:printf("Checking watts intramolecular potential  \n");break;
      case 15:printf("Checking rbar-sigma free energy potential  \n");break;
      case 16:printf("Checking surface potential  \n");break;
      case 17:printf("Checking electronic energy\n");break;
      }/*end switch*/
      printf("---------------\n\n");fflush(stdout);
    }/*endif*/
    if(num_proc>1){Barrier(comm_states);}

    if(inter!=3){
     cputime(&cpu1); 
     get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                   &(class->ghost_atoms));
     if(num_proc>1){Barrier(comm_states);}

     test_force_cp(class,bonded,general_data,cp,inter,&vgen,&vgen2,&vgen3); 

     if(num_proc>1){Barrier(comm_states);}
     cputime(&cpu2); 
     cpu = cpu2-cpu1;
   }/*endif*/

/*---------------------------------------------------------------------------*/
/* A.1) Output the results */

    if(num_proc>1){Barrier(comm_states);}
    if(myid_state==0){
     switch(inter) {
      case 1: printf("The real_space inter energy is %.13g; cputime %g\n",
                     vgen,cpu);
                     vreal=vgen;vcoul=vgen2;vvdw=vgen3;break;
      case 2: printf("The long range correction is %.13g; cputime %g \n",
                         vgen,cpu);
                     vlong=vgen;break;
      case 4: printf("The background energy is %.13g; \n",
                         vgen);
              printf("The self energy is %.13g; cputime %g\n",
                         vgen2,cpu);
                 vbgr=vgen;vself=vgen2;break;
      case 5: printf("The bond  energy is %.13g; cputime %g\n",vgen,cpu);
                 vbond=vgen;break;
      case 6: printf("The bend  energy is %.13g; cputime %g\n",vgen,cpu);
                 vbend=vgen;break;
      case 7: printf("The tors  energy is %.13g; cputime %g\n",vgen,cpu);
                 vtors=vgen;break;
      case 8: printf("The onfo  energy is %.13g; cputime %g\n",vgen,cpu);
                 vonfo=vgen,vonfo_vdw=vgen2;vonfo_coul=vgen3;break;
      case 9: printf("The ecor  energy is %.13g; cputime %g\n",vgen,cpu);
                 vecor=vgen;break;
      case 10: printf("The Uri-Bradley energy is %.13g; cputime %g\n",
                 vgen,cpu);vbend_bnd=vgen;vbend_bnd_bend=vgen2;
                           vbend_bnd_bond=vgen3;break;
      case 11: printf("The free bond energy is %.13g; cputime %g\n",
                          vgen,cpu);vbond_free=vgen;break;
      case 12: printf("The free bend energy is %.13g; cputime %g\n",
                          vgen,cpu);vbend_free=vgen;break;
      case 13: printf("The free tors energy is %.13g; cputime %g\n",
                          vgen,cpu);vtors_free=vgen;break;
      case 14: printf("The watts energy is %.13g; cputime %g\n",
                          vgen,cpu);vwatts_tot=vgen;vwatts_bond=vgen2;
                                    vwatts_bend=vgen3; break;
      case 15: printf("The rbar-sigma energy is %.13g; cputime %g\n",
                          vgen,cpu);vbar_free=vgen;break;
      case 16: printf("The surface energy is %.13g; cputime %g\n",
                          vgen,cpu);vsurf=vgen;break;
      case 17: printf("The total electronic energy is %.13g; cputime %g\n",
                          vgen2,cpu);
               printf("The reciprocal space energy is %.13g; cputime %g\n",
                          general_data->stat_avg.vrecip,cpu);
                break; 
     } /* end switch */
    }/*endif myid_state=0*/
    if(num_proc>1){Barrier(comm_states);}
    if(inter==17){
         cp_ehart = general_data->stat_avg.cp_ehart;
         cp_exc   = general_data->stat_avg.cp_exc;
         cp_muxc  = general_data->stat_avg.cp_muxc;
         cp_eext  = general_data->stat_avg.cp_eext;
         cp_enl   = general_data->stat_avg.cp_enl;
         cp_eke   = general_data->stat_avg.cp_eke;
         vrecip   = general_data->stat_avg.vrecip;
    }/*endif*/

/*---------------------------------------------------------------------------*/
/* B) Save the force, pressure tensor,cp force                               */

    if(num_proc>1){Barrier(comm_states);}
    if(myid_state==0){
      for(ipart=1;ipart<= natm_tot;ipart++){
        fx[ipart] = clatoms_fx[ipart]; 
        fy[ipart] = clatoms_fy[ipart]; 
        fz[ipart] = clatoms_fz[ipart]; 
      }/*endfor*/
      for(j=1;j<=9;j++){
       pvten[j]  = ptens_pvten_tot[j];
      }/*endfor*/
      if(ihess_check == 1){
        hess_ind = (ipart1_h-1)*natm_tot + ipart2_h;
        hess[1] = hess_xx[hess_ind];
        hess[2] = hess_xy[hess_ind];
        hess[3] = hess_xz[hess_ind];
        hess[4] = hess_yy[hess_ind];
        hess[5] = hess_yz[hess_ind];
        hess[6] = hess_zz[hess_ind];
      }/* endif hessian check */
    }/*endif*/
    if(num_proc>1){Barrier(comm_states);}

    if(inter==17){
      cp->cpcoeffs_pos[1].ifcoef_form_up = 0;
      for(i=1;i <= nmall_up;i++){
        fcre_up[i] = cpcoeffs_fcre_up[i];
        fcim_up[i] = cpcoeffs_fcim_up[i];
      }/* endfor i */
      if(cp_lsda== 1 && nstate_dn != 0){
        cp->cpcoeffs_pos[1].ifcoef_form_dn = 0;
        for(i=1;i <= nmall_dn;i++){
          fcre_dn[i] = cpcoeffs_fcre_dn[i];
          fcim_dn[i] = cpcoeffs_fcim_dn[i];
        }/* endfor i */
      }/* endif cp_lsda */
    }/* endif inter */

/*---------------------------------------------------------------------------*/
/* C) Get the numerical force */

    if(ifp_check == 1 && inter!=3) {
      for(iatm=1;iatm<=2;iatm++){
/*  0) Set the atoms */
        if(iatm==1){i=ipart1;}
        if(iatm==2){i=ipart2;}
/*  i) X forces */
        clatoms_x[i] += delta;
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_p,&vgen2,&vgen3); 


        clatoms_x[i] -= (2.0*delta);
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_m,&vgen2,&vgen3); 

        clatoms_x[i] += delta;
        fxb = (vgen_m-vgen_p)/(2.0*delta);
/*  i) Y forces */
        clatoms_y[i] += delta;
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_p,&vgen2,&vgen3); 

        clatoms_y[i] -= (2.0*delta);
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_m,&vgen2,&vgen3); 

        clatoms_y[i] += delta;
        fyb = (vgen_m-vgen_p)/(2.0*delta);
/*  i) Z forces */
        clatoms_z[i] += delta;
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                       &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_p,&vgen2,&vgen3); 

        clatoms_z[i] -= (2.0*delta);
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_m,&vgen2,&vgen3); 

        clatoms_z[i] += delta;
        fzb = (vgen_m-vgen_p)/(2.0*delta);
/*  iv) Print out */
        if(num_proc>1){Barrier(comm_states);}
        if(myid_state==0){
         printf("atm %d fx_num %.13g fx %.13g\n",i,fxb,fx[i]);
         printf("atm %d fy_num %.13g fy %.13g\n",i,fyb,fy[i]);
         printf("atm %d fz_num %.13g fz %.13g\n",i,fzb,fz[i]);
        }/*endif*/
        if(num_proc>1){Barrier(comm_states);}
      }/*endfor:iatm*/ 
/*---------------------------------------------------------------------------*/
/* D) Construct the numerical pressure tensor                                */


     if(cp->cpopts.cp_ptens_calc == 1){    
       cubic_box_flag = general_data->cell.cubic_box_flag;
       general_data->cell.cubic_box_flag = 0;  

       for(j=1;j<=9;j++){ 
         cell_hmat[j] +=  delta;
         cell_hmat_cp[j] += delta;
         for(ipart=1;ipart<= natm_tot;ipart++){
           clatoms_x[ipart] =  sx[ipart]*cell_hmat[1]
                              +sy[ipart]*cell_hmat[4]
                              +sz[ipart]*cell_hmat[7];
            clatoms_y[ipart] = 
                                sx[ipart]*cell_hmat[2]
                               +sy[ipart]*cell_hmat[5]
                               +sz[ipart]*cell_hmat[8];
            clatoms_z[ipart] = 
                                sx[ipart]*cell_hmat[3]
                               +sy[ipart]*cell_hmat[6]
                               +sz[ipart]*cell_hmat[9];
          }/*endfor*/
          gethinv((cell_hmat),(cell_hmati),&(general_data->cell.vol),iperd);
          gethinv((cell_hmat_cp),(cell_hmati_cp),&(general_data->cell.vol_cp),iperd);
          get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                        &(class->ghost_atoms));
          test_force_cp(class,bonded,general_data,cp,inter,
                                                 &vgen_p,&vgen2,&vgen3); 

          cell_hmat[j] -= (2.0*delta);
          cell_hmat_cp[j] -= (2.0*delta);
           for(ipart=1;ipart<= natm_tot;ipart++){
             clatoms_x[ipart] =  sx[ipart]*cell_hmat[1]
                                +sy[ipart]*cell_hmat[4]
                                +sz[ipart]*cell_hmat[7];
             clatoms_y[ipart] =  sx[ipart]*cell_hmat[2]
                                +sy[ipart]*cell_hmat[5]
                                +sz[ipart]*cell_hmat[8];
             clatoms_z[ipart] = sx[ipart]*cell_hmat[3]
                               +sy[ipart]*cell_hmat[6]
                               +sz[ipart]*cell_hmat[9];
           }/*endfor*/
           gethinv((cell_hmat),(cell_hmati),&(general_data->cell.vol),iperd);
           gethinv((cell_hmat_cp),(cell_hmati_cp),&(general_data->cell.vol_cp),iperd);
           get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                         &(class->ghost_atoms));
           test_force_cp(class,bonded,general_data,cp,inter,
                                                  &vgen_m,&vgen2,&vgen3); 

           cell_hmat[j]  += delta;
           cell_hmat_cp[j] += delta;
           hmatd[j] = (vgen_m-vgen_p)/(2.0*delta);
        }/*endfor*/

        general_data->cell.cubic_box_flag = cubic_box_flag;
        gethinv((cell_hmat),(cell_hmati),&(general_data->cell.vol),iperd);
        if(num_proc>1){Barrier(comm_states);}
        if(myid_state==0){
         for(i=1;i<=3;i++){
          ioff = (i-1)*3; 
          for(j=1;j<=3;j++){
           joff = (j-1)*3;
           pvtenb = 0.0;
           for(k=1;k<=3;k++){
             koff = (k-1)*3;
             pvtenb += cell_hmat[(j+koff)]*hmatd[(i+koff)];
           }/*endfor*/
           if(inter==2&&class->energy_ctrl.iswit_vdw<=0){pvtenb*=2.0;}
           printf("P%d%d_num %.13g P%d%d %.13g\n",
                             i,j,pvtenb,i,j,pvten[(i+joff)]);
          }/*endfor*/
         }/*endfor*/     
        }/*endif*/     
        if(num_proc>1){Barrier(comm_states);}
     }/* endif pressure tensor on */
    }/* endif ifp_check */
/*---------------------------------------------------------------------------*/
/* E) Construct the numerical Hessian                                        */

    if(ihess_check == 1 && inter!=3) {
/*  0) Set the atoms */
       i=ipart1_h;
       j=ipart2_h;
/*  i) X forces */
        clatoms_x[j] += delta_h;
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_p,&vgen2,&vgen3); 

        fpx = clatoms_fx[i];
        fpy = clatoms_fy[i];
        fpz = clatoms_fz[i];

        clatoms_x[j] -= (2.0*delta_h);
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_m,&vgen2,&vgen3); 

        fmx = clatoms_fx[i];
        fmy = clatoms_fy[i];
        fmz = clatoms_fz[i];

        clatoms_x[i] += delta_h;
        hxxb = (fmx-fpx)/(2.0*delta_h);
        hyxb = (fmy-fpy)/(2.0*delta_h);
        hzxb = (fmz-fpz)/(2.0*delta_h);
/*  i) Y forces */
        clatoms_y[j] += delta_h;
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_p,&vgen2,&vgen3); 

        fpy = clatoms_fy[i];
        fpz = clatoms_fz[i];

        clatoms_y[j] -= (2.0*delta_h);
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_m,&vgen2,&vgen3); 

        fmy = clatoms_fy[i];
        fmz = clatoms_fz[i];

        clatoms_y[j] += delta_h;

        hyyb = (fmy-fpy)/(2.0*delta_h);
        hzyb = (fmz-fpz)/(2.0*delta_h);

/*  i) Z forces */
        clatoms_z[j] += delta_h;
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                       &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_p,&vgen2,&vgen3); 
        fpz = clatoms_fz[i];

        clatoms_z[j] -= (2.0*delta_h);
        get_ghost_pos(&(class->clatoms_info),&(class->clatoms_pos[1]),
                      &(class->ghost_atoms));
        test_force_cp(class,bonded,general_data,cp,inter,
                                               &vgen_m,&vgen2,&vgen3); 

        fmz = clatoms_fz[i];

        clatoms_z[j] += delta_h;
        hzzb = (fmz-fpz)/(2.0*delta_h);
/*  iv) Print out */
        if(num_proc>1){Barrier(comm_states);}
        if(myid_state==0){
         printf("Hessian element %d %d hxx_num %.13g hxx %.13g\n",i,j,hxxb,hess[1]);
         printf("Hessian element %d %d hxy_num %.13g hxy %.13g\n",i,j,hyxb,hess[2]);
         printf("Hessian element %d %d hxz_num %.13g hxz %.13g\n",i,j,hzxb,hess[3]);
         printf("Hessian element %d %d hyy_num %.13g hyy %.13g\n",i,j,hyyb,hess[4]);
         printf("Hessian element %d %d hyz_num %.13g hyz %.13g\n",i,j,hzyb,hess[5]);
         printf("Hessian element %d %d hzz_num %.13g hzz %.13g\n",i,j,hzzb,hess[6]);
        }/*endif*/
        if(num_proc>1){Barrier(comm_states);}
    }/* endif ih_check==1 */

/*---------------------------------------------------------------------------*/
    if(inter==17){

      if(num_proc>1){Barrier(comm_states);}
      if(myid_state==0){
        printf(
        "Do you want to check the forces on the plane wave coeffs (1/0)\n");
        scanf("%d",&ifp_check);
      }/*endif*/
      if(num_proc>1){Barrier(comm_states);}
      if(num_proc>1){Bcast(&(ifp_check),1,MPI_INT,0,comm_states);}

      if(ifp_check == 1) {
        if(num_proc>1){Barrier(comm_states);}
        if(myid_state==0){
          printf("Enter the coef and the state whose force you wish checked\n");
          scanf("%d %d",&icoef_orig,&istate);printf("\n");
          if(icoef_orig > ncoef || icoef_orig <= 0) {
            printf("The plane wave coefficient number %d you have chosen\n",
                    icoef_orig);
            printf("is out of range  -- using first coefficient instead\n");   
            icoef_orig=1;
          }/*endif*/
          if(istate > nstate_up || istate > nstate_dn || 
             istate <= 0) {
            printf("The state number %d you have chosen\n",istate);
            printf("is out of range  -- using first state instead\n");   
            istate=1;
          }/*endif*/
        }/*endif*/
        if(num_proc>1){Barrier(comm_states);}
        if(num_proc>1){
          Bcast(&(icoef_orig),1,MPI_INT,0,comm_states);
          Bcast(&(istate),1,MPI_INT,0,comm_states);
	}/*endif*/

        if((icoef_orig>=icoef_up_st)&&(icoef_orig<=icoef_up_end)){
          icoef = icoef_orig - icoef_up_st + 1;
        }else{
          icoef = 0;
        }/*endif*/
        ind = (istate-1)*nstate_ncoef_proc_max_up + icoef;

        if(num_proc>1){Barrier(comm_states);}
        if(myid_state==0 && icoef > 0){
          fcre_up_now = fcre_up[ind];fcim_up_now = fcim_up[ind];
   	}/*endif*/
        if(myid_state==0 && icoef == 0){        
          Recv(&fcre_up_now,1,MPI_DOUBLE,MPI_ANY_SOURCE,1,comm_states);
          Recv(&fcim_up_now,1,MPI_DOUBLE,MPI_ANY_SOURCE,2,comm_states);
	}/*endif*/
        if(myid_state!=0 && icoef != 0){        
          Send(&fcre_up[ind],1,MPI_DOUBLE,0,1,comm_states);
          Send(&fcim_up[ind],1,MPI_DOUBLE,0,2,comm_states);
	}/*endif*/

/* Doing real part of up states */
        if(icoef>0){cpcoeffs_cre_up[ind] += delta_cp;}
        test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_p,&vgen2,&vgen3); 

        if(icoef>0){cpcoeffs_cre_up[ind] -= 2.0*delta_cp;}
        test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_m,&vgen2,&vgen3); 

        if(icoef>0){cpcoeffs_cre_up[ind] += delta_cp;}
        if(myid_state==0){fcre_up_b = (vgen_m-vgen_p)/(2.0*delta_cp);}
/* Doing imaginary part of up states */
        if(icoef>0){cpcoeffs_cim_up[ind] += delta_cp;}
        test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_p,&vgen2,&vgen3); 

        if(icoef>0){cpcoeffs_cim_up[ind] -= 2.0*delta_cp;}
        test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_m,&vgen2,&vgen3); 

        if(icoef>0){cpcoeffs_cim_up[ind] += delta_cp;}
        if(myid_state==0){fcim_up_b = (vgen_m-vgen_p)/(2.0*delta_cp);}

/*  i) Print out */
        if(num_proc>1){Barrier(comm_states);}
        if(myid_state==0){
            printf("coef,state %d %d fcre_up_num %.13g fcre_up %.13g\n",
                   icoef_orig,istate,fcre_up_b,fcre_up_now);
            printf("coef,state %d %d fcim_up_num %.13g fcim_up %.13g\n",
                   icoef_orig,istate,fcim_up_b,fcim_up_now);
         }/*endif*/
        if(num_proc>1){Barrier(comm_states);}
/* Doing real part of dn states */
        if(cp_lsda == 1 && nstate_dn != 0){
          if((icoef_orig>=icoef_dn_st)&&(icoef_orig<=icoef_dn_end)){
             icoef = icoef_orig - icoef_dn_st + 1;
          }else{
            icoef = 0;
          }/*endif*/
          ind = (istate-1)*nstate_ncoef_proc_max_dn + icoef;

          if(num_proc>1){Barrier(comm_states);}
          if(myid_state==0 && icoef > 0){
             fcre_dn_now = fcre_dn[ind];fcim_dn_now = fcim_dn[ind];
          }/*endif*/
          if(myid_state==0 && icoef == 0){        
            Recv(&fcre_dn_now,1,MPI_DOUBLE,MPI_ANY_SOURCE,1,comm_states);
            Recv(&fcim_dn_now,1,MPI_DOUBLE,MPI_ANY_SOURCE,2,comm_states);
	  }/*endif*/
          if(myid_state!=0 && icoef != 0){        
            Send(&fcre_dn[ind],1,MPI_DOUBLE,0,1,comm_states);
            Send(&fcim_dn[ind],1,MPI_DOUBLE,0,2,comm_states);
   	  }/*endif*/

          if(icoef>0){cpcoeffs_cre_dn[ind] += delta_cp;}
          test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_p,&vgen2,&vgen3); 

          if(icoef>0){cpcoeffs_cre_dn[ind] -= 2.0*delta_cp;}
          test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_m,&vgen2,&vgen3); 

          if(icoef>0){cpcoeffs_cre_dn[ind] += delta_cp;}
          if(myid_state==0){fcre_dn_b = (vgen_m-vgen_p)/(2.0*delta_cp);}
/* Doing imaginary part of dn states */
          if(icoef>0){cpcoeffs_cim_dn[ind] += delta_cp;}
          test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_p,&vgen2,&vgen3); 

          if(icoef>0){cpcoeffs_cim_dn[ind] -= 2.0*delta_cp;}
          test_force_cp(class,bonded,general_data,cp,inter,
                                                &vgen_m,&vgen2,&vgen3); 

          if(icoef>0){cpcoeffs_cim_dn[ind] += delta_cp;}
          if(myid_state==0){fcim_dn_b = (vgen_m-vgen_p)/(2.0*delta_cp);}

/*  i) Print out */
          if(num_proc>1){Barrier(comm_states);}
          if(myid_state==0){
            printf("coef,state %d %d fcre_dn_num %.13g fcre_dn %.13g\n",
                   icoef_orig,istate,fcre_dn_b,fcre_dn_now);
            printf("coef,state %d %d fcim_dn_num %.13g fcim_dn %.13g\n",
                   icoef_orig,istate,fcim_dn_b,fcim_dn_now);
          }/*endif*/
          if(num_proc>1){Barrier(comm_states);}
        }/* endif cp_lsda */

      }/*endif:ifp_check*/

    }/*endif:CP time is here*/

/*---------------------------------------------------------------------------*/
/* F) Completed test                                                         */
    fflush(stdout);
    if(num_proc>1){Barrier(comm_states);}
    if(myid_state==0){

      printf("\n---------------\n");fflush(stdout);
      switch(inter) {
       case 1:  printf("Finished real_space inter\n"); break;
       case 2:  printf("Finished long \n"); break;
       case 4:  printf("Finished bkgr \n"); break;
       case 5:  printf("Finished bonds\n"); break;
       case 6:  printf("Finished bends\n"); break;
       case 7:  printf("Finished tors \n"); break;
       case 8:  printf("Finished onfos\n"); break;
       case 9:  printf("Finished ecors\n"); break;
       case 10: printf("Finished Uri-Bradleys\n"); break;
       case 11: printf("Finished free bonds \n"); break;
       case 12: printf("Finished free bends \n");break;
       case 13: printf("Finished free tors  \n");break;
       case 14: printf("Finished Watts bonds  \n");break;
       case 15: printf("Finished rbar-sigma free \n");break;
       case 16: printf("Finished surface \n");break;
       case 17: printf("Finished electronic energy\n"); 
                printf("Enter <RETURN> to continue:   ");
                fflush(stdout); getchar();  printf("\n");  break;
      }/* end switch */
      printf("===============\n\n");
      printf("Enter <RETURN> to continue:  ");
      fflush(stdout);getchar();
      printf("\n");

    }/*endif*/
    if(num_proc>1){Barrier(comm_states);}

/*==========================================================================*/

  }/*endfor:inter*/ 

/*==========================================================================*/
/* III) Assign energies */

  if(num_proc>1){Barrier(comm_states);}
  if(myid_state==0){
    vrecip                     += vself+vbgr+vecor;
    vreal                      += vlong+vonfo;
    vvdw                       += vlong + vonfo_vdw + vsurf;
    vcoul                      += vrecip+vonfo_coul;
    general_data->stat_avg.vlong      = vlong;
    general_data->stat_avg.vintert    = vreal+vrecip;
    general_data->stat_avg.vrecip     = vrecip;
    general_data->stat_avg.vvdw       = vvdw;
    general_data->stat_avg.vsurft     = vsurf;
    general_data->stat_avg.vcoul      = vcoul;
    general_data->stat_avg.vbondt     = vbond;
    general_data->stat_avg.vbendt     = vbend;
    general_data->stat_avg.vbend_bndt = vbend_bnd;
    general_data->stat_avg.vbend_bnd_bend = vbend_bnd_bend;
    general_data->stat_avg.vbend_bnd_bond = vbend_bnd_bond;
    general_data->stat_avg.vtorst     = vtors;
    general_data->stat_avg.vbond_free = vbond_free;
    general_data->stat_avg.vbend_free = vbend_free;
    general_data->stat_avg.vtors_free = vtors_free;
    general_data->stat_avg.vbar_free  = vbar_free;
    general_data->stat_avg.vonfot     = vonfo;
    general_data->stat_avg.vintrat    = (vbond+vbend+vbend_bnd+vtors
				   +vbond_free+vbend_free+vtors_free);
    general_data->stat_avg.vbondt_watts = vwatts_bond;
    general_data->stat_avg.vbendt_watts = vwatts_bend;
    general_data->stat_avg.vtot_watts   = vwatts_tot;
  }/*endif*/
  if(num_proc>1){Barrier(comm_states);}
  general_data->stat_avg.cp_ehart   = cp_ehart;
  general_data->stat_avg.cp_exc     = cp_exc; 
  general_data->stat_avg.cp_muxc    = cp_muxc; 
  general_data->stat_avg.cp_eext    = cp_eext;
  general_data->stat_avg.cp_enl     = cp_enl;
  general_data->stat_avg.cp_eke     = cp_eke;

/*==========================================================================*/
/* IV) Done */

  if(num_proc>1){Barrier(comm_states);}
  if(myid_state==0){
   cfree(&(fx[1]));
   cfree(&(fy[1]));
   cfree(&(fz[1]));
  }/*endif*/
  if(num_proc>1){Barrier(comm_states);}

  cfree(&(sx[1]));
  cfree(&(sy[1]));
  cfree(&(sz[1]));

  cfree(&(pvten[1]));
  cfree(&(hmatd[1]));

  cfree(&(fcre_up[1]));
  cfree(&(fcim_up[1]));
  if(cp_lsda== 1 && nstate_dn != 0){
   cfree(&(fcre_dn[1]));
   cfree(&(fcim_dn[1]));
  }/*endif*/

/*-------------------------------------------------------------------*/
   }/*end routine */
/*==========================================================================*/




/*==========================================================================*/
/*cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc*/
/*==========================================================================*/

void test_force_cp(CLASS *class, BONDED *bonded, GENERAL_DATA *general_data,
           CP *cp, int inter,double *vgen, double *vgen2, double *vgen3)

/*==========================================================================*/
{/*begin Routine */
/*==========================================================================*/
/*       Local Variables                                                    */

#include "../typ_defs/typ_mask.h"

 double vvdw,vcoul,vreal;
 double vself,vbgr,vol;
 int i,is;
 int ipart,j,iii,ip,iver_get;
 int ncoef_tot;
 int ires_bond=0;
  double kinet_cp_temp = 0.0;
  double kinet_nhc_cp_temp = 0.0;
  double cp_ehart_tmp = 0.0;
  double cp_exc_tmp = 0.0;
  double cp_muxc_tmp = 0.0;
  double cp_eext_tmp = 0.0;
  double cp_enl_tmp = 0.0;
  double cp_eke_tmp = 0.0;
  double vrecip_tmp = 0.0;

  double vwatts_bend,vwatts_bond,vwatts_tot;

/*----------------*/
/* Local pointers */

 double pext = general_data->statepoint.pext;

 int natm_tot       = class->clatoms_info.natm_tot;
 int pi_beads       = class->clatoms_info.pi_beads; 
 int error_check_on = general_data->error_check_on;

 double *clatoms_fx = class->clatoms_pos[1].fx;
 double *clatoms_fy = class->clatoms_pos[1].fy;
 double *clatoms_fz = class->clatoms_pos[1].fz;
 double *hess_xx      = class->clatoms_pos[1].hess_xx;
 double *hess_xy      = class->clatoms_pos[1].hess_xy;
 double *hess_xz      = class->clatoms_pos[1].hess_xz;
 double *hess_yy      = class->clatoms_pos[1].hess_yy;
 double *hess_yz      = class->clatoms_pos[1].hess_yz;
 double *hess_zz      = class->clatoms_pos[1].hess_zz;

 double *fcre_up    = cp->cpcoeffs_pos[1].fcre_up;
 double *fcim_up    = cp->cpcoeffs_pos[1].fcim_up;
 double *fcre_dn    = cp->cpcoeffs_pos[1].fcre_dn;
 double *fcim_dn    = cp->cpcoeffs_pos[1].fcim_dn;

 double *ptens_pvten = general_data->ptens.pvten;
 double *ptens_pvten_tot = general_data->ptens.pvten_tot;
 double pvten_tmp[10];

 int iperd           = general_data->cell.iperd;
 int nchrg           = class->clatoms_info.nchrg;
 int cp_lsda         = cp->cpopts.cp_lsda;
 int ncoef           = cp->cpcoeffs_info.ncoef;
 int nstate_up       = cp->cpcoeffs_info.nstate_up_proc;
 int nstate_dn       = cp->cpcoeffs_info.nstate_dn_proc;
 int myid_state      = class->communicate.myid_state;  
 int atm_hess_calc   = class->clatoms_info.hess_calc;

 MPI_Comm world       = class->communicate.world;
 MPI_Comm comm_states = class->communicate.comm_states;
 int num_proc            = class->communicate.np;

/*==========================================================================*/
/* Initialize */

    class->for_scr.wght_ter       = 1.0;
    class->for_scr.wght_ter_res   = 1.0;
    bonded->intra_scr.wght_tra     = 1.0;
    bonded->intra_scr.wght_tra_res = 1.0;
    bonded->intra_scr.wght_ter     = 1.0;
    bonded->intra_scr.wght_ter_res = 1.0;
    iver_get =0;
    *vgen = 0.0;
    *vgen2 = 0.0;
    *vgen3 = 0.0;

    for(ipart=1;ipart<= natm_tot;ipart++){
       clatoms_fx[ipart] = 0.0;
       clatoms_fy[ipart] = 0.0;
       clatoms_fz[ipart] = 0.0;
    }/*endfor*/

    if(atm_hess_calc == 3){
     for(ipart=1;ipart <= natm_tot*natm_tot;ipart++){
       hess_xx[ipart] = 0.0;
       hess_xy[ipart] = 0.0;
       hess_xz[ipart] = 0.0;
       hess_yy[ipart] = 0.0;
       hess_yz[ipart] = 0.0;
       hess_zz[ipart] = 0.0;
     }/* endfor */
    }/* endif */
   
    for(j=1;j<=9;j++){
      ptens_pvten[j]     = 0.0;
      ptens_pvten_tot[j] = 0.0;
    }/*endfor*/

/*==========================================================================*/
/* Get the individual forces */

    if((inter==1)&&(myid_state==0)){
       vvdw=0.0;vcoul=0.0;
       force_control(&(class->clatoms_info),&(class->clatoms_pos[1]), 
                     &(class->for_scr),
                     &(class->atommaps),&(general_data->cell),
                     &(general_data->ptens),   &(class->interact),
                     &(class->energy_ctrl),&(class->nbr_list),
                     &(bonded->excl),    &(bonded->intra_scr),vgen,
	             &vvdw,&vcoul,error_check_on,
                     &(class->class_comm_forc_pkg));
       *vgen2 = vcoul;
       *vgen3 = vvdw;
    if( bonded->excl.num_cp > 0 && pi_beads == 1){
      vreal = 0.00;
     mix_coul_corr(&(class->clatoms_info),&(class->clatoms_pos[1]),
                   &(bonded->intra_scr),&(bonded->excl),
                   &(class->interact),
                   &(general_data->cell),&(general_data->ptens),
                   &vreal,general_data->ewald.alp_ewd); 
     *vgen += vreal;
    }/*endif*/

   }/*endif*/

    if((inter==2)&&(myid_state==0)){
       vol = general_data->cell.vol;
       *vgen=0.0;
       if(iperd==3){
         long_range_corr(pi_beads,vgen,vol,&(general_data->ptens),
                         &(class->for_scr),
                         &(class->interact),&(class->energy_ctrl),pext);
       }/*endif*/
    }/*endif*/

    if((nchrg>0)&&(iperd>0)&&(inter==4)&&(myid_state==0)){
       vol = general_data->cell.vol;
       ewald3d_selfbgr_cp(&(class->clatoms_info),&(general_data->ewald),
                          &(general_data->ptens),vol,&vself,&vbgr,iperd);
      *vgen  = vbgr;
      *vgen2 = vself;
    }/*endif*/

    if((bonded->grp_bond_watts.num_33)!=0&&(inter==14)){
        vwatts_bend = 0.0;
        vwatts_bond = 0.0;
        vwatts_tot = 0.0;
         bond_watts_33(&(class->clatoms_info),&(class->clatoms_pos[1]),
                &(bonded->grp_bond_watts),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),&vwatts_bend,
                &vwatts_bond,&vwatts_tot,iver_get,
                &(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter);
      *vgen = vwatts_tot;
      *vgen2 = vwatts_bond;
      *vgen3 = vwatts_bend;
    }/*endif*/

    if((bonded->bond.npow!=0)&&(inter==5)&&(myid_state==0)){
       bond(&(class->clatoms_info),&(class->clatoms_pos[1]),
            &(bonded->bond),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            ires_bond,&(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
    }/*endif*/
     
    if((bonded->bend.npow!=0)&&(inter==6)&&(myid_state==0)){
       bend(&(class->clatoms_info),&(class->clatoms_pos[1]),
            &(bonded->bend),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
    }/*endif*/

    if((bonded->tors.npow!=0)&&(inter==7)&&(myid_state==0)){
       tors(&(class->clatoms_info),&(class->clatoms_pos[1]),
            &(bonded->tors),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pv_real_inter);
    }/*endif*/

    if((bonded->onfo.num!=0)&&(inter==8)&&(myid_state==0)){
       onfo(&(class->clatoms_info),&(class->clatoms_pos[1]),
            &(bonded->onfo),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),
            vgen,vgen2,vgen3,iver_get,&(class->class_comm_forc_pkg),
           class->energy_ctrl.iget_pv_real_inter);
    }/*endif*/

    if((bonded->ecor.num!=0)&&(inter==9)&&(myid_state==0)){
       ecor(&(class->clatoms_info),&(class->clatoms_pos[1]),
            &(bonded->ecor),&(general_data->cell),
            &(bonded->intra_scr),&(general_data->ptens),vgen,iver_get,
            &(class->class_comm_forc_pkg),
            class->energy_ctrl.iget_pe_real_inter,
            class->energy_ctrl.iget_pv_real_inter);
    }/*endif*/

    if((bonded->bend_bnd.num!=0)&&(inter==10)&&(myid_state==0)){
       bend_bnd(&(class->clatoms_info),&(class->clatoms_pos[1]),
                &(bonded->bend_bnd),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,vgen2,vgen3,
                iver_get,&(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter);
    }/*endif*/

    if((bonded->bond_free.num!=0)&&(inter==11)&&(myid_state==0)){
      bond_free(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                &(bonded->bond_free),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                &(class->energy_ctrl),class->communicate.np_forc);
    }/*endif*/

    if((bonded->bend_free.num!=0)&&(inter==12)&&(myid_state==0)){
      bend_free(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                &(bonded->bend_free),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                &(class->energy_ctrl),class->communicate.np_forc);
    }/*endif*/

    if((bonded->tors_free.num!=0)&&(inter==13)&&(myid_state==0)){
      tors_free(&(class->clatoms_info)  ,&(class->clatoms_pos[1])  ,
                &(bonded->tors_free),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                &(class->energy_ctrl),class->communicate.np_forc);
    }/*endif*/

    if( (bonded->rbar_sig_free.nfree!=0) && (inter==15)&&(myid_state==0) ){
      rbar_sig_free(&(class->clatoms_info),&(class->clatoms_pos[1]),
                    &(bonded->rbar_sig_free),&(general_data->cell),
                    &(bonded->intra_scr),&(general_data->ptens),vgen, 
                    &(class->energy_ctrl),class->communicate.np_forc);
    }/*endif*/

    if( (class->surface.isurf_on != 0) && (inter == 16) ){
       surf_pot(&(class->clatoms_info),&(class->clatoms_pos[1]),
                &(class->atommaps),&(class->surface),&(general_data->cell),
                &(bonded->intra_scr),&(general_data->ptens),vgen,
                iver_get,&(class->class_comm_forc_pkg),
                class->energy_ctrl.iget_pv_real_inter, 
                class->energy_ctrl.iget_pe_real_inter);
    }/*endif*/

    if(inter == 17){
      general_data->stat_avg.cp_ehart = 0.0;
      general_data->stat_avg.cp_exc   = 0.0;
      general_data->stat_avg.cp_eext  = 0.0;
      general_data->stat_avg.cp_muxc  = 0.0;
      general_data->stat_avg.cp_enl   = 0.0;
      general_data->stat_avg.cp_eke   = 0.0;
      general_data->stat_avg.vrecip   = 0.0;
      fflush(stdout);

      cp_ks_energy_ctrl(cp,1,&(general_data->ewald),&(class->ewd_scr),
                          &(general_data->cell),
                          &(class->clatoms_info),
                          &(class->clatoms_pos[1]),
                          &(class->atommaps),&(general_data->stat_avg),
                          &(general_data->ptens),
                          &(general_data->simopts),
                          &(class->for_scr));
      fflush(stdout);
      if(num_proc>1){
        cp_enl_tmp   = general_data->stat_avg.cp_enl; 
        cp_eke_tmp   = general_data->stat_avg.cp_eke; 
        cp_ehart_tmp = general_data->stat_avg.cp_ehart; 
        cp_exc_tmp   = general_data->stat_avg.cp_exc; 
        cp_muxc_tmp  = general_data->stat_avg.cp_muxc; 
        cp_eext_tmp  = general_data->stat_avg.cp_eext; 
        vrecip_tmp   = general_data->stat_avg.vrecip;
        for(i=1;i<=9;i++){pvten_tmp[i]=general_data->ptens.pvten_tot[i];}
        Reduce(&cp_enl_tmp,&(general_data->stat_avg.cp_enl),1,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
        Reduce(&cp_eke_tmp,&(general_data->stat_avg.cp_eke),1,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
        Reduce(&cp_ehart_tmp,&(general_data->stat_avg.cp_ehart),1,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
        Reduce(&cp_exc_tmp,&(general_data->stat_avg.cp_exc),1,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
        Reduce(&cp_muxc_tmp,&(general_data->stat_avg.cp_muxc),1,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
        Reduce(&cp_eext_tmp,&(general_data->stat_avg.cp_eext),1,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
        Reduce(&vrecip_tmp,&(general_data->stat_avg.vrecip),1,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
        Reduce(&pvten_tmp[1],&(general_data->ptens.pvten_tot[1]),9,
                     MPI_DOUBLE,MPI_SUM,0,comm_states);
      }/*endif*/

#ifdef DEBUG_CP

     if(myid_state==0){
        printf("cp energies: ehart exc eext enl eke myid\n");
        printf("cp energies %.12g %.12g %.12g %.12g %.12g %d\n",
                general_data->stat_avg.cp_ehart
              , general_data->stat_avg.cp_exc
              , general_data->stat_avg.cp_eext
              , general_data->stat_avg.cp_enl
              , general_data->stat_avg.cp_eke,class->communicate.myid);
      }/*endif*/
#endif
      *vgen2 = (general_data->stat_avg.cp_ehart
              + general_data->stat_avg.cp_exc
              + general_data->stat_avg.cp_eext
              + general_data->stat_avg.cp_enl
              + general_data->stat_avg.cp_eke);
      *vgen = *vgen2 + (general_data->stat_avg.vrecip); 


#ifdef DEBUG_CP_PARTIAL
      *vgen2 = general_data->stat_avg.cp_exc;
      *vgen = *vgen2;
#endif
    }/*endif*/

/*==========================================================================*/
/* Distribute ghost forces into atom forces                            */

    if(myid_state==0){
     distrib_ghost_force(&(class->clatoms_info),&(class->clatoms_pos[1]),
                         &(class->ghost_atoms),iver_get);
    }/*endif*/
    if(num_proc>1){Barrier(comm_states);}

/*-------------------------------------------------------------------*/
  }/*end routine */
/*==========================================================================*/
















